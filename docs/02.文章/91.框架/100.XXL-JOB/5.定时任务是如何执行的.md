---
title: 5. 定时任务是如何执行的
date: 2023-11-20 12:56:32
permalink: /pages/5531a6/
---
## 0. 前言

为什么从执行器开始讲，因为从上向下和从下向上讲都有利有弊，我选择隐藏上层实现的细节，等执行器讲完了再讲调度中心。

由于没有讲调度中心，你只要把调度中心想象为一个黑盒，它会将马上就执行的任务从数据库中查出来，然后发送 HTTP 消息给执行器，执行器拿到`信息`后去执行。

![image-20231121203548419](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20231121203548419.png)

## 1. TriggerParam

调度参数，什么叫调度参数？就是调度中心从数据库中查找到要执行的任务后，将这个参数发送给执行器，执行器根据调度参数内的值进行执行。

这个消息包含什么信息呢？

```java
public class TriggerParam implements Serializable {
    // 使用了 JDK 序列化
    private static final long serialVersionUID = 42L;

    /**
     * 任务id
     */
    private int jobId;

    /**
     * 定时任务名
     */
    private String executorHandler;

    /**
     * 定时任务的参数
     */
    private String executorParams;

    /**
     * 定时任务的阻塞策略                <br></br>
     * 当一个定时任务想要执行，但是负责该任务的线程正在工作时会使用这个阻塞策略判断
     */
    private String executorBlockStrategy;

    /**
     * 任务的过期时间          <br></br>
     * 如果开启了过期时间，执行任务时会额外创建一个新线程执行任务，
     * 之前的线程负责监督新线程执行任务时间是否超时
     */
    private int executorTimeout;

    /**
     * 该任务对应的日志的id
     */
    private long logId;

    /**
     * 打日志的时间
     */
    private long logDateTime;

    /**
     * 运行模式
     */
    private String glueType;

    /**
     * 代码文本
     */
    private String glueSource;

    /**
     * 代码文本更新时间
     */
    private long glueUpdatetime;

    /**
     * 分片索引
     */
    private int broadcastIndex;

    /**
     * 分片总数
     */
    private int broadcastTotal;

    public int getJobId() {
        return jobId;
    }
}
```

其实很多变量在意料之中，id、executorHandler啥的必须有，但是为什么有 logId 呢？执行的时候跟 logId 有什么关系呢？

在上文中我们分析了 xxl-job 的数据库表，着重强调了 xxl_job_log 的两个字段 ：trigger_code、handle_code

- trigger_code ：是否调度成功，也就是 HTTP消息发送成功没有
- handle_code ：是否执行成功，也就是定时任务代码执行过程中是否出现了bug

xxl-job 在消息发送之前，会为每一次执行生成一条日志，这条数据在数据库的 xxl_job_log 中，HTTP消息（也就是TriggerParam ）到达执行器时，这条log就已经有 trigger_code 了。所以我们要在执行的时候记录一些 handle_code、handle_message，等任务执行完再发送回调度中心，调度中心接收到这条消息后就可以补全本次执行的日志。

有了 TriggerParam ，xxl-job 的工作流程变为 ：

- 调度中心从数据库中查询定时任务
- 将任务封装为 TriggerParam 发送给执行器
- 执行器拿到 TriggerParam 后执行对应的任务

现在我们不知道的是 ：定时任务以什么形式存在于执行器、定时任务如何执行的。接下来会具体分析这两点。

## 2. 定义定时任务

定时任务在 Xxl-Job 中以什么形式存在呢？肯定要有一个类封装它。

首先，我们先定义接口，接口规定的是行为，一个任务需要有哪些行为？执行、初始化、销毁。

但是并非所有任务都需要初始化、销毁，所以我们将 IJobHandler 定义为抽象类，给初始化和销毁方法默认实现。

```java
public abstract class IJobHandler {

	public abstract void execute() throws Exception;

	public void init() throws Exception {

	}

	public void destroy() throws Exception {

	}
}
```

一个方法想要执行，肯定要有Class对象、Method方法，同时我想让功能更加丰富，于是给每一个定时任务加上初始化方法、销毁方法。

```java
public class MethodJobHandler extends IJobHandler {
    // bean对象的class
    private final Object target;
    // 需要执行的method
    private final Method method;
    // 初始化和销毁方法
    private Method initMethod;
    private Method destroyMethod;

    public MethodJobHandler(Object target, Method method, Method initMethod, Method destroyMethod) {
        this.target = target;
        this.method = method;

        this.initMethod = initMethod;
        this.destroyMethod = destroyMethod;
    }

    @Override
    public void execute() throws Exception {
        Class<?>[] paramTypes = method.getParameterTypes();
        if (paramTypes.length > 0) {
            method.invoke(target, new Object[paramTypes.length]);       // method-param can not be primitive-types
        } else {
            method.invoke(target);
        }
    }

    @Override
    public void init() throws Exception {
        if(initMethod != null) {
            initMethod.invoke(target);
        }
    }

    @Override
    public void destroy() throws Exception {
        if(destroyMethod != null) {
            destroyMethod.invoke(target);
        }
    }

    @Override
    public String toString() {
        return super.toString()+"["+ target.getClass() + "#" + method.getName() +"]";
    }
}
```

其实上面的逻辑不难对吧，一共就三个方法，执行、初始化、销毁。

- 执行 ：如果没有参数直接就 method.invoke(target)
- 初始化 ：如果初始化Method不为空就执行
- 销毁 ：如果销毁Method不为空就执行

当想要执行一个定时任务的时候，只需要先 new MethodJobHandler，然后调用 jobhandler.executor() 就可执行。

## 3. 收集定时任务

光封装定时任务可不够，我们还要拿到定时任务，也就是凭借调度中心发送来的 TriggerParam 找到 MethodJobHandler，怎么找呢？难道每一次执行任务都需要重新找吗？

别忘了，代码运行之后就没法更改了，所以我们可以趁代码运行后，将所有定时任务收集起来，可以用List、Map这种容器装起来，你想要？没问题，拿任务的唯一标识给我换~~说到唯一标识，聪明的你肯定想到了Map，因为它是 key-value 形式的，我们可以使用 id-jobHandler 也可以使用 jobName-jobHandler 存放任务，跟我们的业务完全符合！

先来看看之前我们写的定时任务代码：

```java
@Component
public class SampleXxlJob {

    @XxlJob("demoJobHandler")
    public void demoJobHandler() throws Exception {
        System.out.println("简单任务实例执行了");
    }
}
```

如果是你，如何获取这个任务呢？由于 SampleXxlJob 这个类已经被注入到 Spring 容器中了，那么我们获取 Spring 容器遍历容器中的所有Bean，如果某个 Bean 有 @XxlJob 这个注解，那么这个 Bean + Method就是我们要找的定时任务。

肯定要由执行器做这种事情，因为我们的项目引入的是执行器依赖，换言之，我们的项目现在就是一个执行器了。

所以我将这个“收集定时任务”的类叫做 `XxlJobSpringExecutor`

在代码中需要拿到 Spring 的上下文 context，然后就可以通过 context 获取所有的bean。

```java
public class XxlJobSpringExecutor implements ApplicationContextAware {

    private static ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        XxlJobSpringExecutor.applicationContext = applicationContext;
    }

    public static ApplicationContext getApplicationContext() {
        return applicationContext;
    }
}
```

现在又有一个新问题：什么时候开始收集定时任务呢？Spring容器初始化前？Spring容器初始化后？

在定时任务中，有可能使用 Mapper、RedisTemplate、rpc 各种Spring bean去完成工作，那肯定是 Spring 的容器初始化之后收集定时任务了。

所以我们要实现 `SmartInitializingSingleton`，在所有单例对象准备好之后，我们开始收集任务。

```java
public class XxlJobSpringExecutor implements ApplicationContextAware, SmartInitializingSingleton {
    
    @Override
    public void afterSingletonsInstantiated() {
        // 在这里收集定时任务
        initJobHandlerMethodRepository(applicationContext);
    }
   
    private static ApplicationContext applicationContext;
    

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        XxlJobSpringExecutor.applicationContext = applicationContext;
    }

    public static ApplicationContext getApplicationContext() {
        return applicationContext;
    }
}
```

再来思考一个问题 ：收集定时任务，我们需要收集什么信息？执行一个任务，换言之，执行一个方法需要什么信息？

1. 被执行的方法 ：method
2. 反射执行任务的代码为 ：method.invoke(class)，所以还需要 class 对象，一个类中可能有多个定时任务，但是管它呢，有多少我要多少。
3. 上面两个属性可以封装为一个 MethodHandler，想要通过定时任务名找到MethodHandler，所以需要拿到定时任务名字。

经过上面的分析，我们初步决定，遍历 Spring 的所有bean，必须拿到以下三个信息：

1. jobName
2. class
3. method

伪代码应该是这样：

```java
// 这个Map负责收集所有定时任务
Map<String, MethodJobHandler> jobMap = new ....();
// 开始遍历每一个Bean
for (Object bean : springBeans) {
    // 收集这个bean中的定时任务
    Map<XxlJob, Method> map = new Map<>();
    Method[] methods = bean.getMethods();
    for (Method method : methods) {
        if (method上有@XxlJob注解) {
            map.put(xxljob, method);
        }
    }
    // 如果这个bean里面没有定时任务就下一个。
    if (map.size() <= 0) continue;
    
    // 遍历Map进行注册，将其注册到
    for (Map.Entry<XxlJob, Method> entry : Map.entrySet()) {
        MethodHandler handler = new MethodJobHandler(bean.class, entry.value());
    	jobMap.put(xxljob.name(), handler);
    }
    
}
```

但是 xxl-job 并没有这么做，它把 `定时任务的收集` 和` 定时任务的注册` 分开进行，为什么？

今天你使用 Spring 集成 xxl-job 可以使用 Spring 容器进行收集，但是明天你没有用 xxl-job 怎么办？收集怎么做？

所以将这两步分开进行，可以减少集成其他框架时的工作量。那么`寻找`这一步就可能有很多种实现方式，但是注册不一样，不管你跟多少框架集成，最终你要给我 bean、method、xxljob注解，这三样东西就行。

由于注册不需要依赖于任何框架， 收集需要依赖于Spring，而业务的逻辑肯定是收集之后再注册，所以我们将行为定义成这样：

```java
public abstract class XxlJobExecutor {
    public void 注册(Object bean, Method method, XxlJob xxljob) {
        // 功能实现
    }
}
```

```java
public abstract class XxlJobSringExecutor extends XxlJobExecutor {
	public  void 收集() {
        // 从定时任务中找出所有定时任务
        Map<XxlJob, Method> map = new Map<>();
        Method[] methods = bean.getMethods();
        for (Method method : methods) {
            if (method上有@XxlJob注解) {
                map.put(xxljob, method);
            }
        }
        // 如果这个bean里面没有定时任务就下一个。
        if (map.size() <= 0) continue;

        // 调用从父类继承过来的注册方法进行注册。
        for (Map.Entry<XxlJob, Method> entry : Map.entrys()) {
        	注册(bean, entry.key, entry.value);
    	}
    }
}
```

先来看一下 XxlJobSpringExecutor 中<font color=Blue>收集定时任务</font>的代码，代码多但是不难：

```java
private void initJobHandlerMethodRepository(ApplicationContext applicationContext) {
        // 容器判空
        if (applicationContext == null) {
            return;
        }
        // 拿到所有bean对象的名字
    	// getBeanNamesForType有三个参数:
    	// type : 类型
    	// includeNonSingletons : 是否包含多实例对象
    	// allowEagerInit : 是否包含懒加载对象
        String[] beanDefinitionNames = applicationContext.getBeanNamesForType(Object.class, false, true);
        for (String beanDefinitionName : beanDefinitionNames) {

            // 通过name拿到bean对象
            Object bean = null;
            Lazy onBean = applicationContext.findAnnotationOnBean(beanDefinitionName, Lazy.class);
            if (onBean!=null){
                logger.debug("xxl-job annotation scan, skip @Lazy Bean:{}", beanDefinitionName);
                continue;
            }else {
                bean = applicationContext.getBean(beanDefinitionName);
            }

            // 这个Map用于收集定时任务，这个Map代表当前遍历的bean中所有的定时任务。
            // Method : 定时任务方法
            // XxlJob : 这个定时任务的注解，通过 XxlJob可以得到定时任务的名字
            Map<Method, XxlJob> annotatedMethods = null;   
            try {
                annotatedMethods = MethodIntrospector.selectMethods(bean.getClass(),
                        new MethodIntrospector.MetadataLookup<XxlJob>() {
                            @Override
                            public XxlJob inspect(Method method) {
                                return AnnotatedElementUtils.findMergedAnnotation(method, XxlJob.class);
                            }
                        });
            } catch (Throwable ex) {
                logger.error("xxl-job method-jobhandler resolve error for bean[" + beanDefinitionName + "].", ex);
            }
            // 如果这个Bean中没有定时任务，跳过
            if (annotatedMethods==null || annotatedMethods.isEmpty()) {
                continue;
            }

            // 已经收集到该Bean的所有定时任务，要把它统一放在一个地方
            // registJobHandler
            for (Map.Entry<Method, XxlJob> methodXxlJobEntry : annotatedMethods.entrySet()) {
                Method executeMethod = methodXxlJobEntry.getKey();
                XxlJob xxlJob = methodXxlJobEntry.getValue();
                // regist
                registJobHandler(xxlJob, bean, executeMethod);
            }

        }
    }
```

1. 拿到所有 Bean 对象的名字，遍历名字，根据名字获取Bean对象
2. 使用 Spring 提供的工具类 MethodIntrospector.selectMethods 查看一个类中有没有加了 @XxlJob 注解的方法
3. 如果有，就将这些方法按照 method:xxljob 的形式封装进 Map 中。
4. 将这个 Bean 中所有定时任务注册到某个地方，以便使用
5. 开始遍历下一个 Bean，重复上述步骤

再看看 XxlJobExecutor 中 <font color=Blue>注册任务</font>的逻辑 ：

```java
public class XxlJobExecutor {
    // 存放 MethodJobHandler 的Map容器
    // key : 定时任务的名字
    private static ConcurrentMap<String, IJobHandler> jobHandlerRepository = new ConcurrentHashMap<String, IJobHandler>();
    public static IJobHandler registJobHandler(String name, IJobHandler jobHandler){
        logger.info(">>>>>>>>>>> xxl-job register jobhandler success, name:{}, jobHandler:{}", name, jobHandler);
        return jobHandlerRepository.put(name, jobHandler);
    }
    protected void registJobHandler(XxlJob xxlJob, Object bean, Method executeMethod){
        if (xxlJob == null) {
            return;
        }

        String name = xxlJob.value();
        //make and simplify the variables since they'll be called several times later
        Class<?> clazz = bean.getClass();
        String methodName = executeMethod.getName();
        if (name.trim().length() == 0) {
            throw new RuntimeException("xxl-job method-jobhandler name invalid, for[" + clazz + "#" + methodName + "] .");
        }
        if (loadJobHandler(name) != null) {
            throw new RuntimeException("xxl-job jobhandler[" + name + "] naming conflicts.");
        }

        executeMethod.setAccessible(true);

        // init and destroy
        Method initMethod = null;
        Method destroyMethod = null;

        if (xxlJob.init().trim().length() > 0) {
            try {
                initMethod = clazz.getDeclaredMethod(xxlJob.init());
                initMethod.setAccessible(true);
            } catch (NoSuchMethodException e) {
                throw new RuntimeException("xxl-job method-jobhandler initMethod invalid, for[" + clazz + "#" + methodName + "] .");
            }
        }
        if (xxlJob.destroy().trim().length() > 0) {
            try {
                destroyMethod = clazz.getDeclaredMethod(xxlJob.destroy());
                destroyMethod.setAccessible(true);
            } catch (NoSuchMethodException e) {
                throw new RuntimeException("xxl-job method-jobhandler destroyMethod invalid, for[" + clazz + "#" + methodName + "] .");
            }
        }

        // registry jobhandler
        registJobHandler(name, new MethodJobHandler(bean, executeMethod, initMethod, destroyMethod));

    }
}
```

registJobHandler(XxlJob xxlJob, Object bean, Method executeMethod)

1. xxlJob ：定时任务头上的注解，含有该任务的名字、初始化方法、销毁方法
2. bean ：该任务方法属于哪个类，需要通过它拿到 class
3. executorMethod ：定时任务的方法

这个方法的总流程：

1. 根据传入的参数获取定时任务的 名字、class对象、方法名
2. 检查参数，并且根据定时任务的名字判断是否已经出现过，不允许任务名重复
3. 如果初始化方法、销毁方法不为空，得到这两个方法
4. 将 class对象、定时任务方法、初始化方法、销毁方法 封装为 MethodJobHandler ，并且以方法名为 key 放入 Map

以后就可以通过定时任务的名称来找到 MethodJobHandler，使用 execute() 来执行。

```java
public static IJobHandler loadJobHandler(String name){
    return jobHandlerRepository.get(name);
}
```

那么现在 收集定时任务的流程为：

1. XxlJobSpringExecutor 找到加了 @XxlJob 注解的方法
2. 注册到 XxlJobExecutor 的 Map 中。

最后，上完整代码：

```java
public class XxlJobSpringExecutor extends XxlJobExecutor implements ApplicationContextAware, SmartInitializingSingleton, DisposableBean {
    @Override
    public void afterSingletonsInstantiated() {
        // 在这里收集定时任务
        initJobHandlerMethodRepository(applicationContext);
    }
   
    private static ApplicationContext applicationContext;
    

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        XxlJobSpringExecutor.applicationContext = applicationContext;
    }

    public static ApplicationContext getApplicationContext() {
        return applicationContext;
    }
    private void initJobHandlerMethodRepository(ApplicationContext applicationContext) {
        if (applicationContext == null) {
            return;
        }
        // init job handler from method
        String[] beanDefinitionNames = applicationContext.getBeanNamesForType(Object.class, false, true);
        for (String beanDefinitionName : beanDefinitionNames) {

            // get bean
            Object bean = null;
            Lazy onBean = applicationContext.findAnnotationOnBean(beanDefinitionName, Lazy.class);
            if (onBean!=null){
                logger.debug("xxl-job annotation scan, skip @Lazy Bean:{}", beanDefinitionName);
                continue;
            }else {
                bean = applicationContext.getBean(beanDefinitionName);
            }

            // filter method
            Map<Method, XxlJob> annotatedMethods = null;   // referred to ：org.springframework.context.event.EventListenerMethodProcessor.processBean
            try {
                annotatedMethods = MethodIntrospector.selectMethods(bean.getClass(),
                        new MethodIntrospector.MetadataLookup<XxlJob>() {
                            @Override
                            public XxlJob inspect(Method method) {
                                return AnnotatedElementUtils.findMergedAnnotation(method, XxlJob.class);
                            }
                        });
            } catch (Throwable ex) {
                logger.error("xxl-job method-jobhandler resolve error for bean[" + beanDefinitionName + "].", ex);
            }
            if (annotatedMethods==null || annotatedMethods.isEmpty()) {
                continue;
            }

            // generate and regist method job handler
            for (Map.Entry<Method, XxlJob> methodXxlJobEntry : annotatedMethods.entrySet()) {
                Method executeMethod = methodXxlJobEntry.getKey();
                XxlJob xxlJob = methodXxlJobEntry.getValue();
                // regist
                registJobHandler(xxlJob, bean, executeMethod);
            }

        }
    }
}
```



```java
public class XxlJobExecutor {
    // 存放 MethodJobHandler 的Map容器
    // key : 定时任务的名字
    private static ConcurrentMap<String, IJobHandler> jobHandlerRepository = new ConcurrentHashMap<String, IJobHandler>();
    public static IJobHandler loadJobHandler(String name){
    	return jobHandlerRepository.get(name);
	}

    protected void registJobHandler(XxlJob xxlJob, Object bean, Method executeMethod){
        if (xxlJob == null) {
            return;
        }

        String name = xxlJob.value();
        //make and simplify the variables since they'll be called several times later
        Class<?> clazz = bean.getClass();
        String methodName = executeMethod.getName();
        if (name.trim().length() == 0) {
            throw new RuntimeException("xxl-job method-jobhandler name invalid, for[" + clazz + "#" + methodName + "] .");
        }
        if (loadJobHandler(name) != null) {
            throw new RuntimeException("xxl-job jobhandler[" + name + "] naming conflicts.");
        }

        executeMethod.setAccessible(true);

        // init and destroy
        Method initMethod = null;
        Method destroyMethod = null;

        if (xxlJob.init().trim().length() > 0) {
            try {
                initMethod = clazz.getDeclaredMethod(xxlJob.init());
                initMethod.setAccessible(true);
            } catch (NoSuchMethodException e) {
                throw new RuntimeException("xxl-job method-jobhandler initMethod invalid, for[" + clazz + "#" + methodName + "] .");
            }
        }
        if (xxlJob.destroy().trim().length() > 0) {
            try {
                destroyMethod = clazz.getDeclaredMethod(xxlJob.destroy());
                destroyMethod.setAccessible(true);
            } catch (NoSuchMethodException e) {
                throw new RuntimeException("xxl-job method-jobhandler destroyMethod invalid, for[" + clazz + "#" + methodName + "] .");
            }
        }

        // registry jobhandler
        registJobHandler(name, new MethodJobHandler(bean, executeMethod, initMethod, destroyMethod));

    }
    public static IJobHandler registJobHandler(String name, IJobHandler jobHandler){
        logger.info(">>>>>>>>>>> xxl-job register jobhandler success, name:{}, jobHandler:{}", name, jobHandler);
        return jobHandlerRepository.put(name, jobHandler);
    }
}
```

其实这两个类的代码远不及如此，我觉得 xxl-job 作为一个小而精的框架，它的代码虽然少但是读起来很难受。

没有遵循 “一个方法占一屏” 的良好习惯~

## 4. 定时任务的执行

现在让我们分析一下使用什么模式去执行定时任务，列举一下可能用到的模式：

1. 每一次接收 TriggerParam 都新创建一个线程去执行。
2. 使用线程池接收 TriggerParam 执行。
3. 一个线程负责一个任务，同一个任务的TriggerParam都由这个线程接收并执行。

如果是你，如何选择？不卖关子，xxl-job 使用第三种模式执行定时任务，而且对这种模式进行了改装 ：

>xxl-job 是以每个线程负责某一个任务的执行，对于两种频率的任务 ：
>
>1. 执行特别频繁的任务
    >
    >    xxl-job 对线程进行了封装，每一个线程内部都有一个阻塞队列，所有 TriggerParam 都会进入负责对应任务的线程的阻塞队列中等待执行。
>
>2. 执行不频繁的任务
    >
    >    线程并不是一直都在工作，它是循环从阻塞队列中取 TriggerParam，如果 3秒钟取不到就进入下一次循环，同时记录这是第几次无效循环，如果超过30次，就将线程销毁。防止线程没事干又占资源。

根据上面的描述，猜测一下 xxl-job 封装的线程需要哪些变量 ：

阻塞队列、无效循环次数、线程是否还在工作的标志、线程是否正在运行任务的标志、任务执行需要的

```java
public class JobThread extends Thread{
    private static Logger logger = LoggerFactory.getLogger(JobThread.class);
	// 此时这个线程负责的定时任务的id
	private int jobId;
    // 该定时任务的 MethodJobHandler
	private IJobHandler handler;
    // 有任务时就会放到这个阻塞队列中
	private LinkedBlockingQueue<TriggerParam> triggerQueue;
    // 防止重复调度
    private Set<Long> triggerLogIdSet;		
	// 该线程是否还在工作
	private volatile boolean toStop = false;
    // 该线程停止的原因是什么，有可能是长时间没有任务，有可能是开发人员手动关闭定时任务
	private String stopReason;
	// 线程是否正在运行任务，"正在运行"不包括线程循环、阻塞等待任务到来，而是真真正正的正在运行任务
    private boolean running = false;    
    // 线程无效循环次数
	private int idleTimes = 0;
    
    public JobThread(int jobId, IJobHandler handler) {
		this.jobId = jobId;
		this.handler = handler;
		this.triggerQueue = new LinkedBlockingQueue<TriggerParam>();
		this.triggerLogIdSet = Collections.synchronizedSet(new HashSet<Long>());

		this.setName("xxl-job, JobThread-"+jobId+"-"+System.currentTimeMillis());
	}
}
```

1. 上面有一个 triggerLogIdSet，其实这个变量很难用上，所以这里先不说了。

2. toStop 和 running 有什么区别呢？

   toStop ：此线程是否还在运行

   running ：此线程是否正在运行任务

   它俩的区别 我们首先要阻塞着从队列中取值，这时 toStop = false，running = false，因为线程确实在运行，但是没有取到任务。

   从队列中取出 TriggerParam 后， toStop = false，running = true，因为现在已经可以开始运行任务了。

```java
public class JobThread extends Thread{
    private static Logger logger = LoggerFactory.getLogger(JobThread.class);
	// 此时这个线程负责的定时任务的id
	private int jobId;
    // 该定时任务的 MethodJobHandler
	private IJobHandler handler;
    // 有任务时就会放到这个阻塞队列中
	private LinkedBlockingQueue<TriggerParam> triggerQueue;
    // 防止重复调度
    private Set<Long> triggerLogIdSet;		
	// 该线程是否还在工作
	private volatile boolean toStop = false;
    // 该线程停止的原因是什么，有可能是长时间没有任务，有可能是开发人员手动关闭定时任务
	private String stopReason;
	// 线程是否正在运行任务，"正在运行"不包括线程循环、阻塞等待任务到来，而是真真正正的正在运行任务
    private boolean running = false;    
    // 线程无效循环次数
	private int idleTimes = 0;			


	public JobThread(int jobId, IJobHandler handler) {
		this.jobId = jobId;
		this.handler = handler;
		this.triggerQueue = new LinkedBlockingQueue<TriggerParam>();
		this.triggerLogIdSet = Collections.synchronizedSet(new HashSet<Long>());

		this.setName("xxl-job, JobThread-"+jobId+"-"+System.currentTimeMillis());
	}
    // 调度中心从数据库中查出将要执行的任务，将这个任务发送给执行器
    // 执行器收到消息后将这次执行放入队列中等待执行
    public ReturnT<String> pushTriggerQueue(TriggerParam triggerParam) {
		// avoid repeat
		if (triggerLogIdSet.contains(triggerParam.getLogId())) {
			logger.info(">>>>>>>>>>> repeate trigger job, logId:{}", triggerParam.getLogId());
			return new ReturnT<String>(ReturnT.FAIL_CODE, "repeate trigger job, logId:" + triggerParam.getLogId());
		}

		triggerLogIdSet.add(triggerParam.getLogId());
		triggerQueue.add(triggerParam);
        return ReturnT.SUCCESS;
	}
    // 线程是否在工作，或者队列中是否有任务等待执行
    public boolean isRunningOrHasQueue() {
        return running || triggerQueue.size()>0;
    }

    @Override
	public void run() {
		// 暂不实现
	}
}
```

这个pushTriggerParam 没干啥事，无非就是判断一下是否重复调度，然后将triggerParam放入阻塞队列。

run方法才是重头戏：

```java
@Override
public void run() {

    // init
    try {
        handler.init();
    } catch (Throwable e) {
        logger.error(e.getMessage(), e);
    }

    // 
    while(!toStop){
        running = false;
        idleTimes++;

        TriggerParam triggerParam = null;
        try {
            triggerParam = triggerQueue.poll(3L, TimeUnit.SECONDS);
            if (triggerParam != null) {
                running = true;
                idleTimes = 0;
                triggerLogIdSet.remove(triggerParam.getLogId());
                // 打印日志，表示任务将要执行
                XxlJobHelper.log("<br>----------- xxl-job job execute start -----------<br>----------- Param:" + xxlJobContext.getJobParam());
                // 执行任务!!!
                handler.execute();
            } else {
                if (idleTimes > 30) {
                    if(triggerQueue.size() == 0) {	
                        // 将此线程停止，或者说移除
                        XxlJobExecutor.removeJobThread(jobId, "excutor idel times over limit.");
                    }
                }
            }
        } catch (Throwable e) {
            if (toStop) {
                XxlJobHelper.log("<br>----------- JobThread toStop, stopReason:" + stopReason);
            }

            // handle result
            StringWriter stringWriter = new StringWriter();
            e.printStackTrace(new PrintWriter(stringWriter));
            String errorMsg = stringWriter.toString();

            XxlJobHelper.handleFail(errorMsg);

            XxlJobHelper.log("<br>----------- JobThread Exception:" + errorMsg + "<br>----------- xxl-job job execute end(error) -----------");
        } finally {
            if(triggerParam != null) {
                // callback handler info
                if (!toStop) {
                    // commonm
                    TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
                        triggerParam.getLogId(),
                        triggerParam.getLogDateTime(),
                        XxlJobContext.getXxlJobContext().getHandleCode(),
                        XxlJobContext.getXxlJobContext().getHandleMsg() )
                                                      );
                } else {
                    // is killed
                    TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
                        triggerParam.getLogId(),
                        triggerParam.getLogDateTime(),
                        XxlJobContext.HANDLE_CODE_FAIL,
                        stopReason + " [job running, killed]" )
                                                      );
                }
            }
        }
    }
    // destroy
    try {
        handler.destroy();
    } catch (Throwable e) {
        logger.error(e.getMessage(), e);
    }
    logger.info(">>>>>>>>>>> xxl-job JobThread stoped, hashCode:{}", Thread.currentThread());
}
```

源代码其实挺复杂的，而且很多东西现在没有讲到，所以我删减了很多，等会补上。

1. 执行初始化方法，进入循环

2. 每次循环都将 idleTimes 加一，从阻塞队列中取值，最多等待三秒，如果超过了就说明现在没有任务，再次循环，如果无效循环 30 次，就会触发 XxlJobExecutor.removeJobThread 将此线程停止并移除。

3. 如果从阻塞队列中取到了值，将 idleTimes置为0，并将 running = true 表示从现在开始要执行任务了

   打印一下日志，使用 handler.execute() 执行任务。

4. 如果出现异常，除了打印日志之外，执行了 XxlJobHelper.handleFail(errorMsg) 这句话，记住它，等会说

5. 在 finally 块中调用 TriggerCallbackThread.pushCallBack() 将任务执行的结果回调给调度中心，这个暂且不说，后面的章节会完善。

但是现在定时任务的执行功能还不完善，我们之前使用的时候是有 <font color=Blue>超时时间</font> 这个功能的，这个功能该如何实现？我们可以新创建一个线程，将定时任务包装为一个 FutureTask，在执行的时候 future.get(seconds)，如果执行超时，就会出现超时异常，我们将其捕获就可以了。

添加了超时时间功能的代码：

```java
@Override
public void run() {

    // init
    try {
        handler.init();
    } catch (Throwable e) {
        logger.error(e.getMessage(), e);
    }

    // execute
    while(!toStop){
        running = false;
        idleTimes++;

        TriggerParam triggerParam = null;
        try {
            triggerParam = triggerQueue.poll(3L, TimeUnit.SECONDS);
            if (triggerParam!=null) {
                running = true;
                idleTimes = 0;
                triggerLogIdSet.remove(triggerParam.getLogId());
                // 打印日志，表示任务将要执行
                XxlJobHelper.log("<br>----------- xxl-job job execute start -----------<br>----------- Param:" + xxlJobContext.getJobParam());
                if (triggerParam.getExecutorTimeout() > 0) {
                    // limit timeout
                    Thread futureThread = null;
                    try {
                        FutureTask<Boolean> futureTask = new FutureTask<Boolean>(new Callable<Boolean>() {
                            @Override
                            public Boolean call() throws Exception {
                                handler.execute();
                                return true;
                            }
                        });
                        futureThread = new Thread(futureTask);
                        futureThread.start();

                        Boolean tempResult = futureTask.get(triggerParam.getExecutorTimeout(), TimeUnit.SECONDS);
                    } catch (TimeoutException e) {

                        XxlJobHelper.log("<br>----------- xxl-job job execute timeout");
                        XxlJobHelper.log(e);
                    } finally {
                        futureThread.interrupt();
                    }
                } else {
                    // just execute
                    handler.execute();
                }
            } else {
                if (idleTimes > 30) {
                    if(triggerQueue.size() == 0) {	
                        XxlJobExecutor.removeJobThread(jobId, "excutor idel times over limit.");
                    }
                }
            }
        } catch (Throwable e) {
            if (toStop) {
                XxlJobHelper.log("<br>----------- JobThread toStop, stopReason:" + stopReason);
            }

            // handle result
            StringWriter stringWriter = new StringWriter();
            e.printStackTrace(new PrintWriter(stringWriter));
            String errorMsg = stringWriter.toString();

            XxlJobHelper.handleFail(errorMsg);

            XxlJobHelper.log("<br>----------- JobThread Exception:" + errorMsg + "<br>----------- xxl-job job execute end(error) -----------");
        } finally {
            if(triggerParam != null) {
                // callback handler info
                if (!toStop) {
                    // commonm
                    TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
                        triggerParam.getLogId(),
                        triggerParam.getLogDateTime(),
                        XxlJobContext.getXxlJobContext().getHandleCode(),
                        XxlJobContext.getXxlJobContext().getHandleMsg() )
                                                      );
                } else {
                    // is killed
                    TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
                        triggerParam.getLogId(),
                        triggerParam.getLogDateTime(),
                        XxlJobContext.HANDLE_CODE_FAIL,
                        stopReason + " [job running, killed]" )
                                                      );
                }
            }
        }
    }
    // destroy
    try {
        handler.destroy();
    } catch (Throwable e) {
        logger.error(e.getMessage(), e);
    }
    logger.info(">>>>>>>>>>> xxl-job JobThread stoped, hashCode:{}", Thread.currentThread());
}
```

可以看到这个循环其实很容易停下来，我们只需要将 toStop 设置为 true，这个多线程的循环就会停止。

```java
public void toStop(String stopReason) {
    toStop = true;
    this.stopReason = stopReason;
}
```

## 5. XxlJobContext

在上面的代码中，XxlJobContext 和 XxlJobHelper 出现了很多次，XxlJobHelper 我们在刚才已经试用了，就是记录日志的嘛，但是它不仅仅可以记录日志，还可以修改 XxlJobContext 的状态，那么 XxlJobContext 是什么呢？

只要涉及 Context 的都是上下文，XxlJobContext 也不例外，我叫它任务上下文，使用 Context 的作用就是我们可以将某些信息直接放里面，想用的时候直接 XxlJobContext.getXXX() 拿出来，而不是将信息作为方法的参数传来传去的。

```java
public class XxlJobContext {

    public static final int HANDLE_CODE_SUCCESS = 200;
    public static final int HANDLE_CODE_FAIL = 500;
    public static final int HANDLE_CODE_TIMEOUT = 502;

    // ---------------------- base info ----------------------

    /**
     * 任务id
     */
    private final long jobId;

    /**
     * 任务参数
     */
    private final String jobParam;

    /**
     * 任务日志文件的文件名
     */
    private final String jobLogFileName;

    /**
     * 分片索引
     */
    private final int shardIndex;

    /**
     * 分片总数
     */
    private final int shardTotal;

    /**
     * handleCode：执行结果
     *
     *      200 : success
     *      500 : fail
     *      502 : timeout
     *
     */
    private int handleCode;

    /**
     * 执行信息
     */
    private String handleMsg;
    
    private static InheritableThreadLocal<XxlJobContext> contextHolder = new InheritableThreadLocal<XxlJobContext>(); 

    public static void setXxlJobContext(XxlJobContext xxlJobContext){
        contextHolder.set(xxlJobContext);
    }

    public static XxlJobContext getXxlJobContext(){
        return contextHolder.get();
    }

}
```

除了一些基本信息以外，XxlJobContext 提供了 setXxlJobContext 的方法，将 XxlJobContext 放到 ThreadLocal 中，这个 InheritableThreadLocal 继承自 ThreadLocal，作用是可以保证父子线程共用数据。

那么它什么时候创建？必然是有任务执行的时候创建。

想要更改 XxlJobContext 的数据其实也挺麻烦的

```java
XxlJobContext xxlJobContext = XxlJobContext.getXxlJobContext();
xxlJobContext.setHandlerMsg("xxxxxx");
```

想要修改 XxlJobContext 中的 handle_code、handle_Msg 需要两行代码，挺麻烦的。

所以 XxlJobHelper 给我们封装了一下，比如获取当前正在执行的任务的参数、获取当前正在执行的任务的调度信息、设置当前正在执行的任务的执行结果...

```java
public class XxlJobHelper {

    // ---------------------- base info ----------------------

    /**
     * current JobId
     *
     * @return
     */
    public static long getJobId() {
        XxlJobContext xxlJobContext = XxlJobContext.getXxlJobContext();
        if (xxlJobContext == null) {
            return -1;
        }

        return xxlJobContext.getJobId();
    }

    /**
     * current JobParam
     *
     * @return
     */
    public static String getJobParam() {
        XxlJobContext xxlJobContext = XxlJobContext.getXxlJobContext();
        if (xxlJobContext == null) {
            return null;
        }

        return xxlJobContext.getJobParam();
    }

    // ---------------------- for log ----------------------

    /**
     * current JobLogFileName
     *
     * @return
     */
    public static String getJobLogFileName() {
        XxlJobContext xxlJobContext = XxlJobContext.getXxlJobContext();
        if (xxlJobContext == null) {
            return null;
        }

        return xxlJobContext.getJobLogFileName();
    }

    public static int getShardIndex() {
        XxlJobContext xxlJobContext = XxlJobContext.getXxlJobContext();
        if (xxlJobContext == null) {
            return -1;
        }

        return xxlJobContext.getShardIndex();
    }

    /**
     * current ShardTotal
     *
     * @return
     */
    public static int getShardTotal() {
        XxlJobContext xxlJobContext = XxlJobContext.getXxlJobContext();
        if (xxlJobContext == null) {
            return -1;
        }

        return xxlJobContext.getShardTotal();
    }
    public static boolean handleSuccess(){
        return handleResult(XxlJobContext.HANDLE_CODE_SUCCESS, null);
    }
    public static boolean handleSuccess(String handleMsg) {
        return handleResult(XxlJobContext.HANDLE_CODE_SUCCESS, handleMsg);
    }
    public static boolean handleFail(){
        return handleResult(XxlJobContext.HANDLE_CODE_FAIL, null);
    }

    /**
     * handle fail with log msg
     *
     * @param handleMsg
     * @return
     */
    public static boolean handleFail(String handleMsg) {
        return handleResult(XxlJobContext.HANDLE_CODE_FAIL, handleMsg);
    }

    /**
     * handle timeout
     *
     * @return
     */
    public static boolean handleTimeout(){
        return handleResult(XxlJobContext.HANDLE_CODE_TIMEOUT, null);
    }

    /**
     * handle timeout with log msg
     *
     * @param handleMsg
     * @return
     */
    public static boolean handleTimeout(String handleMsg){
        return handleResult(XxlJobContext.HANDLE_CODE_TIMEOUT, handleMsg);
    }

    /**
     * @param handleCode
     *
     *      200 : success
     *      500 : fail
     *      502 : timeout
     *
     * @param handleMsg
     * @return
     */
    public static boolean handleResult(int handleCode, String handleMsg) {
        XxlJobContext xxlJobContext = XxlJobContext.getXxlJobContext();
        if (xxlJobContext == null) {
            return false;
        }

        xxlJobContext.setHandleCode(handleCode);
        if (handleMsg != null) {
            xxlJobContext.setHandleMsg(handleMsg);
        }
        return true;
    }

}
```

这代码我就不细讲了，无非就是获取 XxlJobContext，set/get 啥的。你就记住，使用 XxlJobContext 可以获取当前正在执行的任务的信息，而 XxlJobHelper 提供了便于操作它的API。

现在可以贴 JobThread#run 的全部代码了

```java
@Override
public void run() {

    // init
    try {
        handler.init();
    } catch (Throwable e) {
        logger.error(e.getMessage(), e);
    }

    // execute
    while(!toStop){
        running = false;
        idleTimes++;

        TriggerParam triggerParam = null;
        try {
            triggerParam = triggerQueue.poll(3L, TimeUnit.SECONDS);
            if (triggerParam!=null) {
                running = true;
                idleTimes = 0;
                triggerLogIdSet.remove(triggerParam.getLogId());
				// 生成日志文件，这个以后会说
                String logFileName = XxlJobFileAppender.makeLogFileName(new Date(triggerParam.getLogDateTime()), triggerParam.getLogId());
                
                // 任务刚准备开始执行，是创建 XxlJobContext 的大好时机啊
                XxlJobContext xxlJobContext = new XxlJobContext(
                    triggerParam.getJobId(),
                    triggerParam.getExecutorParams(),
                    logFileName,
                    triggerParam.getBroadcastIndex(),
                    triggerParam.getBroadcastTotal()
                );

                // 将 XxlJobContext 放入 ThreadLocal
                XxlJobContext.setXxlJobContext(xxlJobContext);

                // 打印日志，开始执行!
                XxlJobHelper.log("<br>----------- xxl-job job execute start -----------<br>----------- Param:" + xxlJobContext.getJobParam());
				// 如果设置了超时时间，开启新线程，包装为 FutureTask 执行。超时就结束
                if (triggerParam.getExecutorTimeout() > 0) {
                    // limit timeout
                    Thread futureThread = null;
                    try {
                        FutureTask<Boolean> futureTask = new FutureTask<Boolean>(new Callable<Boolean>() {
                            @Override
                            public Boolean call() throws Exception {
								// 由于是开启新线程执行，所以要重新设置一下。
                                XxlJobContext.setXxlJobContext(xxlJobContext);
								// 开始执行
                                handler.execute();
                                // 如果能执行完返回true
                                return true;
                            }
                        });
                        futureThread = new Thread(futureTask);
                        futureThread.start();
						// get结果，指定时间内get不到就抛出异常。
                        Boolean tempResult = futureTask.get(triggerParam.getExecutorTimeout(), TimeUnit.SECONDS);
                    } catch (TimeoutException e) {

                        XxlJobHelper.log("<br>----------- xxl-job job execute timeout");
                        XxlJobHelper.log(e);

                        // 捕获异常之后除了记录日志，还要将timeout记录在context中。
                        XxlJobHelper.handleTimeout("job execute timeout ");
                    } finally {
                        futureThread.interrupt();
                    }
                } else {
                    // just execute
                    handler.execute();
                }

                // 走到这里如果 handler_code 还是 <= 0，只能说这个任务丢失了
                if (XxlJobContext.getXxlJobContext().getHandleCode() <= 0) {
                    XxlJobHelper.handleFail("job handle result lost.");
                } else {
                    // 否则这个任务就是成功了。因为万一出现异常会被catch到根本不会走到这里
                    String tempHandleMsg = XxlJobContext.getXxlJobContext().getHandleMsg();
                    tempHandleMsg = (tempHandleMsg!=null&&tempHandleMsg.length()>50000)
                        ?tempHandleMsg.substring(0, 50000).concat("...")
                        :tempHandleMsg;
                    XxlJobContext.getXxlJobContext().setHandleMsg(tempHandleMsg);
                }
                // 打印日志
                XxlJobHelper.log("<br>----------- xxl-job job execute end(finish) -----------<br>----------- Result: handleCode="
                                 + XxlJobContext.getXxlJobContext().getHandleCode()
                                 + ", handleMsg = "
                                 + XxlJobContext.getXxlJobContext().getHandleMsg()
                                );

            } else {
                // 如果没有在队列中取出任务，并且已经无效循环了30次 (也就是90s)，将线程销毁
                if (idleTimes > 30) {
                    // 再次重复判断，避免并发情况
                    if(triggerQueue.size() == 0) {	
                        XxlJobExecutor.removeJobThread(jobId, "excutor idel times over limit.");
                    }
                }
            }
        } catch (Throwable e) {
            if (toStop) {
                XxlJobHelper.log("<br>----------- JobThread toStop, stopReason:" + stopReason);
            }

            // handle result
            StringWriter stringWriter = new StringWriter();
            e.printStackTrace(new PrintWriter(stringWriter));
            String errorMsg = stringWriter.toString();
			// 如果出现异常，将任务设置为失败，并填上失败信息
            XxlJobHelper.handleFail(errorMsg);

            XxlJobHelper.log("<br>----------- JobThread Exception:" + errorMsg + "<br>----------- xxl-job job execute end(error) -----------");
        } finally {
            // 将此任务的执行结果发送给调度中心，这个先不管。
            if(triggerParam != null) {
                // callback handler info
                if (!toStop) {
                    // commonm
                    TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
                        triggerParam.getLogId(),
                        triggerParam.getLogDateTime(),
                        XxlJobContext.getXxlJobContext().getHandleCode(),
                        XxlJobContext.getXxlJobContext().getHandleMsg() )
                                                      );
                } else {
                    // is killed
                    TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
                        triggerParam.getLogId(),
                        triggerParam.getLogDateTime(),
                        XxlJobContext.HANDLE_CODE_FAIL,
                        stopReason + " [job running, killed]" )
                                                      );
                }
            }
        }
    }

    // 能走到这里，说明 toStop变量被设置为true了，有以下两种可能:
    // 1. 开发人员手动关闭定时任务
    // 2. 任务很久没有执行，触发了 XxlJobExecutor.removeJobThread()将线程移除
    // 现在要判断队列中是否还有值，如果是因为第二种情况走出的while循环，根本不会走下面的逻辑
    // 如果定时任务关闭了，将所有这个任务没执行的"次数"全部取出来发送给调度中心，告诉开发人员这些没执行。
    while(triggerQueue !=null && triggerQueue.size()>0){
        TriggerParam triggerParam = triggerQueue.poll();
        if (triggerParam!=null) {
            // is killed
            TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
                triggerParam.getLogId(),
                triggerParam.getLogDateTime(),
                XxlJobContext.HANDLE_CODE_FAIL,
                stopReason + " [job not executed, in the job queue, killed.]")
                                              );
        }
    }

    // destroy
    try {
        handler.destroy();
    } catch (Throwable e) {
        logger.error(e.getMessage(), e);
    }

    logger.info(">>>>>>>>>>> xxl-job JobThread stoped, hashCode:{}", Thread.currentThread());
}
```

这里放出全部 JobThread 的代码：（真的可以下载源码去看，在这里看不能 ctrl 点击，难受）

为了方便阅读，我将 `判断是否有超时时间` 那段逻辑封装为了 doExecutor 方法，希望你能理解。

```java
public class JobThread extends Thread {
    private static Logger logger = LoggerFactory.getLogger(JobThread.class);

    /**
     * 定时任务的id
     */
    private int jobId;

    /**
     * 此任务绑定的对象
     */
    private IJobHandler handler;

    /**
     * 内含需要被执行的定时任务(触发器参数)
     */
    private LinkedBlockingQueue<TriggerParam> triggerQueue;

    /**
     * 正在调度的任务的日志id集合(线程安全)
     */
    private Set<Long> triggerLogIdSet;

    /**
     * 该组件是否结束，如果这个组件结束，说明该线程正在负责的定时任务被取消了
     */
    private volatile boolean toStop = false;

    /**
     * 该任务被取消的原因
     */
    private String stopReason;

    /**
     * 该线程是否正在运行(正在运行任务，如果只是等待从队列中取任务不算运行中)
     */
    private boolean running = false;

    /**
     * 空转次数，达到一定次数便销毁该线程，连阻塞都不让它阻塞
     */
    private int idleTimes = 0;

    public JobThread(int jobId, IJobHandler handler) {
        this.jobId = jobId;
        this.handler = handler;
        this.triggerQueue = new LinkedBlockingQueue<>();
        this.triggerLogIdSet = Collections.synchronizedSet(new HashSet<>());
        this.setName("xxl-job, JobThread - " + jobId + " - " + System.currentTimeMillis());
    }

    /**
     * 调度参数放入调度队列
     *
     * @param triggerParam
     */
    public Result pushTriggerQueue(TriggerParam triggerParam) {
        // 如果日志id集合中包含此调度参数，说明可能重复调度了
        if (triggerLogIdSet.contains(triggerParam.getLogId())) {
            logger.info(">>>>>>>>>>>> repeate trigger job, logId: {}", triggerParam.getLogId());
            return Result.error("repeate trigger job, logId:" + triggerParam.getLogId());
        }
        triggerLogIdSet.add(triggerParam.getLogId());
        triggerQueue.add(triggerParam);
        return Result.success();
    }

    /**
     * 判断该线程是否正在忙碌，正在运行任务、阻塞队列中有调度参数等待执行 代表忙碌
     */
    public boolean isRunningOrHasQueue() {
        return running || !triggerQueue.isEmpty();
    }

    @Override
    public void run() {
        // 执行初始化方法
        runInitMethod();
        // 开始执行
        while (!toStop) {
            // 刚进入循环不算执行，得到调度参数才算执行
            running = false;
            idleTimes += 1;
            TriggerParam triggerParam = null;
            try {
                triggerParam = triggerQueue.poll(3L, TimeUnit.SECONDS);
                if (triggerParam == null) {
                    // 如果阻塞3s没有调度参数，并且现在已经循环了30次，队列中还是没有数据，得，销毁线程
                    if (idleTimes > 30 && triggerQueue.isEmpty()) {
                        // 调用XxlJobExecutor.removeJobThread() 去销毁线程
                        XxlJobExecutor.removeJobThread(jobId, "太久不执行，线程销毁了");
                    }
                } else {
                    // 调度参数不为空，将running改为true, 空转次数改为0
                    running = true;
                    idleTimes = 0;
                    triggerLogIdSet.remove(triggerParam.getLogId());
                    String logFileName = XxlJobFileAppender.makeLogFileName(new Date(triggerParam.getLogDateTime()), triggerParam.getLogId());
                    XxlJobContext xxlJobContext = new XxlJobContext(
                            triggerParam.getJobId(),
                            triggerParam.getExecutorParams(),
                            logFileName,
                            triggerParam.getBroadcastIndex(),
                            triggerParam.getBroadcastTotal()
                    );
                    XxlJobContext.setXxlJobContext(xxlJobContext);
                    // 记录日志，开始执行
                    XxlJobHelper.log("<br>----------- xxl-job job execute start -----------<br>----------- Param:" + xxlJobContext.getJobParam());
                    // 执行定时任务，根据是否设置超时时间来执行。
                    // 如果没有设置超时时间就直接执行。 如果设置了超时时间就开启子线程，使用 FutureTask 执行。
                    doExecute(triggerParam, xxlJobContext);

                    // 判断执行结果
                    if (XxlJobContext.getXxlJobContext().getHandleCode() <= 0) {
                        XxlJobHelper.handleFail("job handle result lost.");
                    } else {
                        // 如果执行结果大于0，不管成功还是失败就直接记录消息，等回调线程去回调。如果执行成功了handleMsg为空
                        String tempHandleMsg = XxlJobContext.getXxlJobContext().getHandleMsg();
                        tempHandleMsg = (tempHandleMsg != null && tempHandleMsg.length() > 50000) ? tempHandleMsg.substring(0, 50000).concat("...") : tempHandleMsg;
                        XxlJobContext.getXxlJobContext().setHandleMsg(tempHandleMsg);
                    }
                    // 回调的执行结果咱不管，现在的执行结果先记录日志
                    XxlJobHelper.log("<br>------------ xxl-job job execute end(finish)-------------<br>------------- Result: handleCode=" +
                            XxlJobContext.getXxlJobContext().getHandleCode() +
                            ", handleMsg = " +
                            XxlJobContext.getXxlJobContext().getHandleMsg()
                    );
                }
            } catch (Exception e) {
                if (toStop) {
                    // 如果线程停止了，记录停止原因、异常
                    XxlJobHelper.log("<br>----------- JobThread toStop, stopReason:" + stopReason);
                    StringWriter stringWriter = new StringWriter();
                    e.printStackTrace(new PrintWriter(stringWriter));
                    String errorMessage = stringWriter.toString();
                    // 将XxlJobContext中任务的执行状态改为失败
                    XxlJobHelper.handleFail(errorMessage);
                    XxlJobHelper.log("<br>----------- JobThread Exception:" + errorMessage +
                            "<br>----------- xxl-job job execute end(error)");
                }
            } finally {
                // 在finally中执行将日志回调给调度中心的操作
                if (triggerParam != null) {
                    // 如果线程没有停止，不管任务执行成功还是失败，回调给调度中心即可。
                    // 如果线程被终止了，将stopReason发送给调度中心
                    if (!toStop) {
                        TriggerCallbackThread.pushCallback(new HandlerCallbackParam(
                                triggerParam.getLogId(),
                                triggerParam.getLogDateTime(),
                                XxlJobContext.getXxlJobContext().getHandleCode(),
                                XxlJobContext.getXxlJobContext().getHandleMsg()
                        ));
                    } else {
                        TriggerCallbackThread.pushCallback(new HandlerCallbackParam(
                                triggerParam.getLogId(),
                                triggerParam.getLogDateTime(),
                                XxlJobContext.HANDLE_CODE_FAIL,
                                stopReason + "[job running, killed]"
                        ));
                    }
                }
            }

        }

        // 退出while循环，最后将队列中没来得及执行的数据拿出来回调回去，告诉调度中心这些数据没有执行
        while (triggerQueue != null && !triggerQueue.isEmpty()) {
            TriggerParam triggerParam = triggerQueue.poll();
            if (triggerParam == null) {
                continue;
            }
            TriggerCallbackThread.pushCallback(new HandlerCallbackParam(
                    triggerParam.getLogId(),
                    triggerParam.getLogDateTime(),
                    XxlJobContext.HANDLE_CODE_FAIL,
                    stopReason + " [job not executed, in the job queue, killed.]"
            ));
        }
        // 执行销毁方法
        runDestroyMethod();
    }

    private void runInitMethod() {
        try {
            handler.init();
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        }
    }

    private void runDestroyMethod() {
        try {
            handler.destroy();
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        }
    }

    /**
     * 执行定时任务，根据是否设置超时时间来执行。
     * 如果设置了超时时间就开启子线程，使用 FutureTask 执行。
     * 如果没有设置超时时间就直接执行
     *
     * @param triggerParam
     * @param xxlJobContext
     */
    private void doExecute(TriggerParam triggerParam, XxlJobContext xxlJobContext) throws Exception {
        // 没有设置超时时间，直接执行，设置了超时时间，开启子线程执行，此线程监督子线程执行
        if (triggerParam.getExecutorTimeout() == 0) {
            try {
                handler.execute();
            } catch (Exception e) {
                XxlJobHelper.log("<br>-------------- xxl-job job execute timeout");
                XxlJobHelper.log(e);
                XxlJobHelper.handleFail("job execute fail, exception message: " + e.getMessage());
            }
        } else {
            Thread futureThread = null;
            try {
                FutureTask<Boolean> futureTask = new FutureTask<>(new Callable<Boolean>() {
                    @Override
                    public Boolean call() throws Exception {
                        XxlJobContext.setXxlJobContext(xxlJobContext);
                        handler.execute();
                        return true;
                    }
                });
                // 创建并启动线程，get结果，如果指定时间get不到，说明超时
                futureThread = new Thread(futureTask);
                futureThread.start();
                Boolean tempResult = futureTask.get(triggerParam.getExecutorTimeout(), TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                XxlJobHelper.log("<br>-------------- xxl-job job execute timeout");
                XxlJobHelper.log(e);
                // 将超时设置到 XxlJobContext 中
                XxlJobHelper.handleTimeout("job execute timeout");
            } finally {
                futureThread.interrupt();
            }
        }
    }

    public void toStop(String stopReason) {
        toStop = true;
        this.stopReason = stopReason;
    }


    public IJobHandler getHandler() {
        return handler;
    }

}
```



## 7. 执行器对 JobThread 的管理

JobThread 完成le ，现在来想想怎么将 TriggerParam 放入阻塞队列吧，JobThread 提供了 API ：pushTriggerQueue.

怎么调度它呢？如何知道负责某个任务的线程是否存在呢？如何将线程销毁呢（谁来调用 toStop() 方法呢）？

这些都是问题待解决的问题。上面介绍 MethodJobHandler 时将 MethodJobHandler 收集起来放入 Map 中，那么 JobThread 也可以收集起来进行统一的管理啊，用 jobId-JobThread 这种 key-value 形式将线程封装进 Map 中，调度中心传入 TriggerParam 后，通过 jobId 找到负责该任务的线程，调用 pushTriggerQueue 将 TriggerParam 放入队列等待执行。那么由谁来管理这个装 JobThread 的 Map 呢？肯定是执行器，所以将这个 Map 放入 XxlJobExecutor 中。

```java
// 存放 JobThread线程 的Map
private static ConcurrentHashMap<Integer, JobThread> jobThreadRepository = new ConcurrentHashMap<>();

// 根据任务id获取对应线程
public static JobThread loadJobThread(int jobId) {
    return jobThreadRepository.get(jobId);
}

// 注册新任务
public static JobThread registJobThread(int jobId, IJobHandler handler, String removeOldReason) {
    JobThread newJobThread = new JobThread(jobId, handler);
    newJobThread.start();
    JobThread oldJobThread = jobThreadRepository.put(jobId, newJobThread);
    // 如果任务之前注册过，可能是web端更改了任务。将旧线程停止。
    if (oldJobThread != null) {
        oldJobThread.toStop(removeOldReason);
        oldJobThread.interrupt();
    }
    return newJobThread;
}

// 销毁线程
public static JobThread removeJobThread(int jobId, String removeReason) {
    JobThread oldJobThread = jobThreadRepository.remove(jobId);
    if (oldJobThread != null) {
        oldJobThread.toStop(removeReason);
        oldJobThread.interrupt();
    }
    return oldJobThread;
}
```

说一下为啥停止线程的时候不仅要调用 toStop 方法，还要调用 interrupt 方法呢？

1. 线程中使用 while(!toStop){} 的形式进行无限循环，所以想要停止这个线程肯定要让线程退出循环，调用 toStop 方法会将 toStop = true
2. 在 JobThread.run() 方法中，有 阻塞着从队列中取值 的步骤存在，如果想要让线程停止工作，肯定要让线程先退出阻塞状态再退出循环，所以调用 interrupt 纯粹是不让线程阻塞这么长时间。

补全了对于 JobThread 的管理，现在的执行器执行任务的流程就很清晰了：

1. 执行器接收到来自调度中心的 TriggerParam

2. show me code：

    ```java
    JobThread thread = XxlJobExecutor.loadJobThread(triggerPara.getJobId());
    if (thread == null) {
        thread = XxlJobExecutor.registJobThread(这里先不说);
    }
    thread.pushTriggerQueue(triggerParam);
    ```

3. 调度参数放入队列后就会等待取出执行。这个步骤可以参考 JobThread 的代码

最后，来看看 `thread = XxlJobExecutor.registJobThread(这里先不说)` 这一步，想要注册线程，就必须拿到 MethodJobHandler，怎么拿到？TriggerParam 中有 任务名，我们之前将所有 任务名-JobHandler 的键值对封装到 XxlJobExecutor 的一个 Map 中了，所以可以先通过那个 Map 获取 MethodJobHandler 再进行新建线程。

## 7. 总结

放上面涉及到的全部代码：

```java
@Configuration
public class XxlJobSpringExecutor extends XxlJobExecutor implements ApplicationContextAware, SmartInitializingSingleton, DisposableBean {
    private static Logger logger = LoggerFactory.getLogger(XxlJobSpringExecutor.class);

    private static ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        XxlJobSpringExecutor.applicationContext = applicationContext;
    }

    @Override
    public void afterSingletonsInstantiated() {
        try {
            initJobHandlerMethodRepository(applicationContext);
            super.start();
        } catch (Exception e) {
            logger.error(e.getMessage());
        }
    }

    @Override
    public void destroy() throws Exception {
        super.stop();
    }

    private void initJobHandlerMethodRepository(ApplicationContext applicationContext) throws NoSuchMethodException {
        if (applicationContext == null) return;
        String[] beanDefinitionNames = applicationContext.getBeanNamesForType(Object.class, false, true);
        for (String beanDefinitionName : beanDefinitionNames) {
            Object bean = applicationContext.getBean(beanDefinitionName);
            Map<Method, XxlJob> annotatedMethods = null;
            try {
                annotatedMethods = MethodIntrospector.selectMethods(bean.getClass(),
                        new MethodIntrospector.MetadataLookup<XxlJob>() {
                            @Override
                            public XxlJob inspect(Method method) {
                                return AnnotatedElementUtils.findMergedAnnotation(method, XxlJob.class);
                            }
                        }
                );

            } catch (Exception e) {
                // 记录日志，代码太长就不放了
            }
            if (CollectionUtil.isEmpty(annotatedMethods)) {
                continue;
            }
            // 将定时任务注册为JobHandler
            for (Map.Entry<Method, XxlJob> methodXxlJobEntry : annotatedMethods.entrySet()) {
                Method method = methodXxlJobEntry.getKey();
                XxlJob value = methodXxlJobEntry.getValue();
                registJobHandler(value, bean, method);
            }

        }

    }

    public static ApplicationContext getApplicationContext() {
        return applicationContext;
    }
}
```



```java
public class XxlJobExecutor {
    private static final Logger logger = LoggerFactory.getLogger(XxlJobExecutor.class);
        // ---------------------- job handler repository ----------------------
    private static ConcurrentMap<String, IJobHandler> jobHandlerRepository = new ConcurrentHashMap<String, IJobHandler>();
    public static IJobHandler loadJobHandler(String name){
        return jobHandlerRepository.get(name);
    }
    public static IJobHandler registJobHandler(String name, IJobHandler jobHandler){
        return jobHandlerRepository.put(name, jobHandler);
    }
    protected void registJobHandler(XxlJob xxlJob, Object bean, Method executeMethod){
        if (xxlJob == null) {
            return;
        }

        String name = xxlJob.value();
        
        Class<?> clazz = bean.getClass();
        String methodName = executeMethod.getName();
        if (name.trim().length() == 0) {
            throw new RuntimeException("xxl-job method-jobhandler name invalid, for[" + clazz + "#" + methodName + "] .");
        }
        if (loadJobHandler(name) != null) {
            throw new RuntimeException("xxl-job jobhandler[" + name + "] naming conflicts.");
        }

        executeMethod.setAccessible(true);

        // init and destroy
        Method initMethod = null;
        Method destroyMethod = null;

        if (xxlJob.init().trim().length() > 0) {
            try {
                initMethod = clazz.getDeclaredMethod(xxlJob.init());
                initMethod.setAccessible(true);
            } catch (NoSuchMethodException e) {
                throw new RuntimeException("xxl-job method-jobhandler initMethod invalid, for[" + clazz + "#" + methodName + "] .");
            }
        }
        if (xxlJob.destroy().trim().length() > 0) {
            try {
                destroyMethod = clazz.getDeclaredMethod(xxlJob.destroy());
                destroyMethod.setAccessible(true);
            } catch (NoSuchMethodException e) {
                throw new RuntimeException("xxl-job method-jobhandler destroyMethod invalid, for[" + clazz + "#" + methodName + "] .");
            }
        }

        // registry jobhandler
        registJobHandler(name, new MethodJobHandler(bean, executeMethod, initMethod, destroyMethod));

    }


    // ---------------------- job thread repository ----------------------
    private static ConcurrentMap<Integer, JobThread> jobThreadRepository = new ConcurrentHashMap<Integer, JobThread>();
    public static JobThread registJobThread(int jobId, IJobHandler handler, String removeOldReason){
        JobThread newJobThread = new JobThread(jobId, handler);
        newJobThread.start();
        

        JobThread oldJobThread = jobThreadRepository.put(jobId, newJobThread);	
        if (oldJobThread != null) {
            oldJobThread.toStop(removeOldReason);
            oldJobThread.interrupt();
        }

        return newJobThread;
    }

    public static JobThread removeJobThread(int jobId, String removeOldReason){
        JobThread oldJobThread = jobThreadRepository.remove(jobId);
        if (oldJobThread != null) {
            oldJobThread.toStop(removeOldReason);
            oldJobThread.interrupt();

            return oldJobThread;
        }
        return null;
    }

    public static JobThread loadJobThread(int jobId){
        return jobThreadRepository.get(jobId);
    }
}
```

```java
public class TriggerParam implements Serializable {
    private static final long serialVersionUID = 42L;

    /**
     * 任务id
     */
    private int jobId;

    /**
     * 定时任务名字
     */
    private String executorHandler;

    /**
     * 定时任务的参数
     */
    private String executorParams;

    /**
     * 定时任务的阻塞策略                <br></br>
     * 当一个定时任务想要执行，但是负责该任务的线程正在工作时会使用这个阻塞策略判断
     */
    private String executorBlockStrategy;

    /**
     * 任务的过期时间          <br></br>
     * 如果开启了过期时间，执行任务时会额外创建一个新线程执行任务，
     * 之前的线程负责监督新线程执行任务时间是否超时
     */
    private int executorTimeout;

    /**
     * 该任务对应的日志的id
     */
    private long logId;

    /**
     * 打日志的时间
     */
    private long logDateTime;

    /**
     * 运行模式
     */
    private String glueType;

    /**
     * 代码文本
     */
    private String glueSource;

    /**
     * 代码文本更新时间
     */
    private long glueUpdatetime;

    /**
     * 分片索引
     */
    private int broadcastIndex;

    /**
     * 分片总数
     */
    private int broadcastTotal;
}
```

```java
package com.xxl.job.core.thread;

import com.xxl.job.core.biz.model.HandleCallbackParam;
import com.xxl.job.core.biz.model.ReturnT;
import com.xxl.job.core.biz.model.TriggerParam;
import com.xxl.job.core.context.XxlJobContext;
import com.xxl.job.core.context.XxlJobHelper;
import com.xxl.job.core.executor.XxlJobExecutor;
import com.xxl.job.core.handler.IJobHandler;
import com.xxl.job.core.log.XxlJobFileAppender;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.*;


/**
 * handler thread
 * @author xuxueli 2016-1-16 19:52:47
 */
public class JobThread extends Thread{
	private static Logger logger = LoggerFactory.getLogger(JobThread.class);

	private int jobId;
	private IJobHandler handler;
	private LinkedBlockingQueue<TriggerParam> triggerQueue;
	private Set<Long> triggerLogIdSet;		

	private volatile boolean toStop = false;
	private String stopReason;

    private boolean running = false;    
	private int idleTimes = 0;			


	public JobThread(int jobId, IJobHandler handler) {
		this.jobId = jobId;
		this.handler = handler;
		this.triggerQueue = new LinkedBlockingQueue<TriggerParam>();
		this.triggerLogIdSet = Collections.synchronizedSet(new HashSet<Long>());

		// assign job thread name
		this.setName("xxl-job, JobThread-"+jobId+"-"+System.currentTimeMillis());
	}
	public IJobHandler getHandler() {
		return handler;
	}

    /**
     * new trigger to queue
     *
     * @param triggerParam
     * @return
     */
	public ReturnT<String> pushTriggerQueue(TriggerParam triggerParam) {
		// avoid repeat
		if (triggerLogIdSet.contains(triggerParam.getLogId())) {
			logger.info(">>>>>>>>>>> repeate trigger job, logId:{}", triggerParam.getLogId());
			return new ReturnT<String>(ReturnT.FAIL_CODE, "repeate trigger job, logId:" + triggerParam.getLogId());
		}

		triggerLogIdSet.add(triggerParam.getLogId());
		triggerQueue.add(triggerParam);
        return ReturnT.SUCCESS;
	}

    /**
     * kill job thread
     *
     * @param stopReason
     */
	public void toStop(String stopReason) {
		/**
		 * Thread.interrupt只支持终止线程的阻塞状态(wait、join、sleep)，
		 * 在阻塞出抛出InterruptedException异常,但是并不会终止运行的线程本身；
		 * 所以需要注意，此处彻底销毁本线程，需要通过共享变量方式；
		 */
		this.toStop = true;
		this.stopReason = stopReason;
	}

    /**
     * is running job
     * @return
     */
    public boolean isRunningOrHasQueue() {
        return running || triggerQueue.size()>0;
    }

    @Override
	public void run() {

    	// init
    	try {
			handler.init();
		} catch (Throwable e) {
    		logger.error(e.getMessage(), e);
		}

		// execute
		while(!toStop){
			running = false;
			idleTimes++;

            TriggerParam triggerParam = null;
            try {
				// to check toStop signal, we need cycle, so wo cannot use queue.take(), instand of poll(timeout)
				triggerParam = triggerQueue.poll(3L, TimeUnit.SECONDS);
				if (triggerParam!=null) {
					running = true;
					idleTimes = 0;
					triggerLogIdSet.remove(triggerParam.getLogId());

					// log filename, like "logPath/yyyy-MM-dd/9999.log"
					String logFileName = XxlJobFileAppender.makeLogFileName(new Date(triggerParam.getLogDateTime()), triggerParam.getLogId());
					XxlJobContext xxlJobContext = new XxlJobContext(
							triggerParam.getJobId(),
							triggerParam.getExecutorParams(),
							logFileName,
							triggerParam.getBroadcastIndex(),
							triggerParam.getBroadcastTotal());

					// init job context
					XxlJobContext.setXxlJobContext(xxlJobContext);

					// execute
					XxlJobHelper.log("<br>----------- xxl-job job execute start -----------<br>----------- Param:" + xxlJobContext.getJobParam());

					if (triggerParam.getExecutorTimeout() > 0) {
						// limit timeout
						Thread futureThread = null;
						try {
							FutureTask<Boolean> futureTask = new FutureTask<Boolean>(new Callable<Boolean>() {
								@Override
								public Boolean call() throws Exception {

									// init job context
									XxlJobContext.setXxlJobContext(xxlJobContext);

									handler.execute();
									return true;
								}
							});
							futureThread = new Thread(futureTask);
							futureThread.start();

							Boolean tempResult = futureTask.get(triggerParam.getExecutorTimeout(), TimeUnit.SECONDS);
						} catch (TimeoutException e) {

							XxlJobHelper.log("<br>----------- xxl-job job execute timeout");
							XxlJobHelper.log(e);

							// handle result
							XxlJobHelper.handleTimeout("job execute timeout ");
						} finally {
							futureThread.interrupt();
						}
					} else {
						// just execute
						handler.execute();
					}

					// valid execute handle data
					if (XxlJobContext.getXxlJobContext().getHandleCode() <= 0) {
						XxlJobHelper.handleFail("job handle result lost.");
					} else {
						String tempHandleMsg = XxlJobContext.getXxlJobContext().getHandleMsg();
						tempHandleMsg = (tempHandleMsg!=null&&tempHandleMsg.length()>50000)
								?tempHandleMsg.substring(0, 50000).concat("...")
								:tempHandleMsg;
						XxlJobContext.getXxlJobContext().setHandleMsg(tempHandleMsg);
					}
					XxlJobHelper.log("<br>----------- xxl-job job execute end(finish) -----------<br>----------- Result: handleCode="
							+ XxlJobContext.getXxlJobContext().getHandleCode()
							+ ", handleMsg = "
							+ XxlJobContext.getXxlJobContext().getHandleMsg()
					);

				} else {
					if (idleTimes > 30) {
						if(triggerQueue.size() == 0) {	
							XxlJobExecutor.removeJobThread(jobId, "excutor idel times over limit.");
						}
					}
				}
			} catch (Throwable e) {
				if (toStop) {
					XxlJobHelper.log("<br>----------- JobThread toStop, stopReason:" + stopReason);
				}

				// handle result
				StringWriter stringWriter = new StringWriter();
				e.printStackTrace(new PrintWriter(stringWriter));
				String errorMsg = stringWriter.toString();

				XxlJobHelper.handleFail(errorMsg);

				XxlJobHelper.log("<br>----------- JobThread Exception:" + errorMsg + "<br>----------- xxl-job job execute end(error) -----------");
			} finally {
                if(triggerParam != null) {
                    // callback handler info
                    if (!toStop) {
                        // commonm
                        TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
                        		triggerParam.getLogId(),
								triggerParam.getLogDateTime(),
								XxlJobContext.getXxlJobContext().getHandleCode(),
								XxlJobContext.getXxlJobContext().getHandleMsg() )
						);
                    } else {
                        // is killed
                        TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
                        		triggerParam.getLogId(),
								triggerParam.getLogDateTime(),
								XxlJobContext.HANDLE_CODE_FAIL,
								stopReason + " [job running, killed]" )
						);
                    }
                }
            }
        }

		// callback trigger request in queue
		while(triggerQueue !=null && triggerQueue.size()>0){
			TriggerParam triggerParam = triggerQueue.poll();
			if (triggerParam!=null) {
				// is killed
				TriggerCallbackThread.pushCallBack(new HandleCallbackParam(
						triggerParam.getLogId(),
						triggerParam.getLogDateTime(),
						XxlJobContext.HANDLE_CODE_FAIL,
						stopReason + " [job not executed, in the job queue, killed.]")
				);
			}
		}

		// destroy
		try {
			handler.destroy();
		} catch (Throwable e) {
			logger.error(e.getMessage(), e);
		}

		
	}
}
```



