---
title: 缓存一致性协议：MESI
date: 2023-08-02 13:17:16
permalink: /pages/ee38bc/
---
## 1. Cache

为什么 CPU 要有缓存？

CPU 要从内存中取数据，但是 CPU 太快了，内存太慢了，速度差异过大导致 CPU 的性能无法利用。所以操作系统使用 Cache 作为 CPU 与内存之间的缓存。就像 Redis 在 Java程序与MySQL之间充当缓存作用似的。

Cache 通常分为三级 ：L1、L2、L3。级别越低，离 CPU 越近，速度越快，但是存储容量越小。

在多核 CPU 中，每个 CPU 都有各自的 L1 与 L2，而L3是所有 CPU 共享的 。

<img src="https://typorehwf.oss-cn-chengdu.aliyuncs.com/CPU-Cache.png" alt="img" style="zoom:80%;" />



**Cache 是由很多个 Cache Line 组成的**，CPU Line 是 CPU 从内存读取数据的基本单位，而 CPU Line 是由各种标志（Tag）+ 数据块（Data Block）组成，你可以在下图清晰的看到：

<img src="https://typorehwf.oss-cn-chengdu.aliyuncs.com/20230802120745.png" style="zoom:80%;" />

事实上，数据不光是只有读操作，还有写操作，那么如果数据写入 Cache 之后，内存与 Cache 相对应的数据将会不同，这种情况下 Cache 和内存数据都不一致了，于是我们肯定是要把 Cache 中的数据同步到内存里的。

有两种写方式：

1. 写直达 ：<font color=Purple>*Write Through*</font>，写入数据时不仅往缓存中写，还要往内存中写。
2. 写回 ：<font color=Purple>*Write Back*</font>，写数据时只往缓存中写，并把数据标记为脏数据，写数据时遇到脏数据就会将脏数据同步到内存。

## 2. 缓存一致性问题

现在的 CPU 都是多核的，由于 L1 与 L2 是 CPU 独自拥有的，那么就会带来缓存一致性问题，如果不能解决缓存一致性问题，那就会造成结果错误。

那么什么是缓存一致性问题呢？为什么会出现缓存一致性问题？

假如现在又两个核：CPU **A** 与 CPU **B**，在他们的 L1 中都有一个变量 i = 0。

现在 A 将它修改为1，还没来的及刷到内存中就被 B 读取了，B 读取的数据 i = 0。

但是 B 比 A 执行的晚，A 又把 i 改了，那么 B 得到的 i 理应为 1。

这就是缓存一致性问题。

想要解决这个问题，就要保证以下两点 ：

>1. ***写传播*** ：一个 CPU 修改了共享变量，要 **通知** 其他所有 CPU。
>2. ***事物的串行化*** ：这个 “通知” 被 不同CPU 接收的顺序应该相同。

第一点很容易理解，一个 CPU 修改了共享变量，在刷新到内存之前就要通知别的 CPU，以免出现缓存不一致问题。

第二点有点犯迷糊，来举个例子：

CPU A 发出了两条通知 ：<font color=Orange>**A** 将 i 修改为 ***100***</font>、<font color=Purple>**A** 将 i 修改为 ***200***</font>

如果出现以下情况，那么最终结果就会导致不一样：

- CPU B 接收的通知顺序为 ：<font color=Purple>**A** 将 i 修改为 ***200***</font>、<font color=Orange>**A** 将 i 修改为 ***100***</font>。  
在 CPU B 中，i 的最终结果为 <font color=Orange>100</font>
- CPU C 接收的通知顺序为 ：<font color=Orange>**A** 将 i 修改为 ***100***</font>、<font color=Purple>**A** 将 i 修改为 ***200***</font>。  
在 CPU C 中，i 的最终结果为 <font color=Purple>200</font>

所以，我们要保证 B 号核心和 C 号核心都能看到**相同顺序的数据变化**。

接下来看一下 CPU 是如何实现 **写传播** 和 **事务的串行化** 的。

## 3. 总线嗅探

写传播机制很简单 ：当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心。

最常见实现的方式是**总线嗅探（*Bus Snooping*）** ：某个 CPU 更新了数据时会将修改以**广播的形式**发送到 总线，而其他 CPU时刻监听总线，一旦发生写信号，立刻检查自己的 Cache 中是否有这个数据，如果有就把这个写操作同步过来。

总线嗅探机制很简单，但是 CPU 要时刻监听总线，这无异于会增加很多负担。并且总线嗅探只能实现写传播，不能实现 事务的串行化。

**MESI 协议**就通过 总线嗅探机制 实现了 事务的串行化，做到了缓存的一致性。

## 4. MESI协议

MESI 协议其实是 4 个状态单词的开头字母缩写，分别是：

- <font color=Purple>*Modified*</font>，已修改
- <font color=Purple>*Exclusive*</font>，独占
- <font color=Purple>*Shared*</font>，共享
- <font color=Purple>*Invalidated*</font>，已失效

这四个状态来标记 Cache Line 四个不同的状态。

「已修改」状态就是我们前面提到的脏标记，代表该 Cache Block 上的数据已经被更新过，但是还没有写到内存里。如果 CPU 中某个数据是已修改，那么可以直接对这个数据写，不需要通知其他 CPU。

「已失效」状态，表示的是这个 Cache Block 里的数据已经失效了，不可以读取该状态的数据。

「独占」和「共享」状态都代表 Cache Block 里的数据是干净的，也就是说，这个时候 Cache Block 里的数据和内存里面的数据是一致性的。

「独占」和「共享」的差别在于，独占状态的时候，数据只存储在一个 CPU 核心的 Cache 里，而其他 CPU 核心的 Cache 没有该数据。这个时候，如果要向独占的 Cache 写数据，就可以直接自由地写入，而不需要通知其他 CPU 核心，因为只有你这有这个数据，就不存在缓存一致性的问题了，于是就可以随便操作该数据。

另外，在「独占」状态下的数据，如果有其他核心从内存读取了相同的数据到各自的 Cache ，那么这个时候，独占状态下的数据就会变成共享状态。

那么，「共享」状态代表着相同的数据在多个 CPU 核心的 Cache 里都有，所以当我们要更新 Cache 里面的数据的时候不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后再更新当前 Cache 里面的数据。

:::note 那么MESI如何实现事务的串行化呢？
**当一个处理器要修改一个缓存行时，它首先将该缓存行的状态设置为修改状态，然后将该缓存行的数据复制到自己的缓存中。
此时，其他处理器无法访问该缓存行。其他处理器如果要访问该缓存行，必须先将其状态设置为无效，然后从主存中读取最新的数据。
这样，每个处理器都可以按照顺序执行事务，保证了事务的串行化。**
:::

