---
title: InnoDB - B+树索引
date: 2023-06-08 21:47:16
permalink: /pages/26e2d2/
---
# InnoDB - B+树索引

在阅读前你需要了解的前置知识：
[InnoDB行格式](01.InnoDB%20-%20行格式.md)
[InnoDB页结构](05.InnoDB%20-%20页结构.md)


## 1. 没有索引的查找

### 1.1 在一页中查找

本篇的主题是索引，在正式介绍索引之前，我们需要了解一下**没有索引的查找**（下面只针对精确查找，并且现在一页中讨论）

如果一条SQL是这样的：

```sql
select * from user where 列名 = 'xxx';
```

对于精确查找，又分为两种情况：**主键查找**和**非主键查找**。

* 主键查找：在页目录的槽位中进行二分法查找，找到差值最小的槽后去User Record区域寻找对应的组，在组中就可以查找到相应数据。
* 非主键查找：由于槽位中并不会记录非主键的信息，只能从最小记录挨个遍历寻找符合条件的行数据。

### 1.2 在很多页中查找

上述情况只是针对只有一页数据的情况，大部分情况下我们的数据是很多的，往往有很多页来存储数据，那么查询的步骤就变成这样：

* 遍历所有页
* 在每一页中使用二分法查找数据。

在没有索引的情况下，不论是根据主键或者其他字段进行查找，我们无法快速定位到数据所在的页，所以只能沿着页组成的双向链表挨个遍历，遍历所有页的效率是非常低的，这时候索引的优势就体现出来了。

## 2. 索引

为了故事的顺利发展，我们先创建一个表：

```sql
create table indx_demo (   
	c1 int ,   
	c2 int ,   
	c3 char(1),   
	primary key(c1) 
) row_format = compact;
```

这个新建的 index_demo 表中有2个 int 类型的列，1个char类型的列，c1为主键，而且规定了这个表使用Compact行格式来存储数据。

为了方便理解，我们简化行格式，只保留本篇文章用到的：

* record_type ：此条记录的类型

  * 0：普通记录
  * 1：B+树非叶子节点记录
  * 2：最小记录
  * 3：最大记录
* next_record：此条记录的下一条记录

于是我们向 index_demo 表中插入几条数据后：

![image](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230604182143-znou5ww.png)

### 2.1 一个简单的索引方案

先说哈，MySQL用的不是这个小标题中的索引方案，只是我们在尝试使用自己的想法来设计一个索引方案。

我们在根据某个搜索条件查询时为什么要遍历所有的数据页呢？**因为各个页的数据没有规律，或者说我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不遍历所有的数据页。**

如果我们想要快速定位到需要查找的记录在哪个数据页该怎么办？还记得我们为了根据主键值快速定位一条记录在页中的位置而设立的**目录**吗？我们也可以借鉴这个思想：目录

这个目录必须做到以下功能：

1. 下一个**数据页**中的第一条数据的主键值必须大于上一个**数据页**中最后一条数据的主键值，这样才能用二分法。
2. 给页建立目录，这样才能获得快速到达页

（假设一页只能存储3条用户记录）

我们向其中插入三条数据：

![image](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230604182337-83o4gvo.png)

这一页共有三条数据，id分别为1、2、5.

当我们继续向表中插入一条id = 4的数据，这个页已经满了，所以MySQL会创建新的页来存储数据。

![image](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230604182346-3sc4o8o.png)

为什么新分配的页的编号是24而不是11呢？其实MySQL并没有规定页码必须按照顺序，只要两个页之间有指针相连组成一个双向链表就行了。

页10中最大用户记录的id为5，页24中最小记录的id为4，这就不符合下一个数据页中用户记录的主键值大于该页中用户记录的主键值的要求。

我们想要页24的最小主键值大于页10的最大主键值，这时就需要将5移动到24，将4移动到10。

这个过程表明了在对页的记录进行增删改的时候，MySQL会通过一些操作，例如记录移动、页的增加/删除来维持：下一个数据页中的主键值永远比上一个数据页中的主键值大。这个过程可以称为：页分裂。

页分裂是非常消耗资源的，所以MySQL建议我们给一个表创建一个无意义且自增的主键。避免老是发生页分裂。

第一条我们已经满足了：下一个数据页中的主键值必须大于上一个数据页中的主键值，这样才能用二分法。

下面来看第二个：给页建立目录

站在页的内部，我们将数据进行分组，给各个组建立了目录，加快对于数据的查询。

现在我们将站在页的外部，（也就是表的角度）给页建立目录，加快找到目标页的速度。

先向这张表中多插入几条数据：

![image](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230604182418-923vh7i.png)

现在共有4个页，每个页有3条用户记录。

因为这些16KB的页在物理存储上很可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们可以根据 主键值-页码 生成一个目录，这样就可以根据主键值定位页码了。每一个页对应一个目录项，每个目录项包含：页码、页码对应的页中数据的最小主键值。

于是，一个索引雏形就出现了：

![image](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230604182425-n9r4lwi.png)

### 2.2 InnoDB的索引方案

上面小节的标题是”一个简单的索引方案“，是因为它只是一个雏形，还具有很多不完备的地方。它具有以下几个缺点：

1. InnoDB是使用页作为管理存储空间的基本单位，也就是最多能保证16KB的连续存储空间，而随着表中记录的增多，需要非常大的连续的存储空间，这显然是不现实的。
2. 我们经常会对数据进行增删改，假设我们把24页中的数据全都删除了，那么24页也就没有了存在的必要，那么对应的目录项也就没有了存在的必要，这牵扯到页、目录项的移动，牵一发而动全身

所以如何灵活的管理目录项是个问题，MySQL设计者当然想出了解决这个问题的方案：**目录项同样使用页进行存储。**

他们复用了存储用户数据的页来存储目录项（也就是索引）。我们可以区别的称呼其为：用户记录、索引记录（目录项记录）。

那么如何区分一条记录是用户记录还是索引记录呢？record_type属性。record_type各个取值代表的意思：

* 0 ：用户记录
* 1 ：目录项记录（索引记录）
* 2 ：最小记录
* 3 ：最大记录

我们将上述图完善一下就是：

![image](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230604182446-x17idv7.png)

这张图你有没有感觉像什么数据结构？**B+树！**

从图中我们可以看出：

* 叶子节点存储主键以及数据，数据的record_type为0
* 非叶子节点只存储主键+页目录，数据的record_type为1
* 每一层的节点（每一个节点即一页）使用双向链表连接。

于是当我们查询一条记录时可以分为两步：

1. 确定 目录项记录 页：根据主键，使用二分法确定这个记录大概处在哪个页
2. 确定 记录在哪个组：根据页目录，使用二分法的槽位确定这个记录在哪个组，进而从组中找到该数据。

从头到尾都是二分法。

需要注意的是：我们一般用一个顶点来存储目录项记录的页。于是上面那张图的最终版为：

![image](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230604182503-dec7fix.png)

更像B+树了~

假如一个页可以有1000个子页（也就是一页中有1000条记录），一层是一个页，第二层就可以有1000页，第三层就可以有1000 * 1000 页，每一页有1000条数据，那么第三层可以有 1000 * 1000 * 1000 条数据，所以我们的数据绝大多数只有两~三层B+树。

想起之前背的面试题：

相比于二叉树，B+树的层级更低...(阿巴阿巴阿巴)

现在知道到底为什么了吧。

但是现在还有一个问题：

如果我们为 age 创建了一个二级索引，那么在B+树的非叶子节点中的记录就是：age对应页码。但是age是很容易重复的，13这个age有可能对应很多个页码，进而出现了这种情况：age=13对应了 54、32、15这三页，再插入一条age=13的数据，这条数据该往哪个页中插入呢？

为了让新插入记录能找到自己在那个页里，我们需要在记录中再添加一个唯一字段，什么字段适合做这个唯一索引呢？主键啊。

所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的

* 字段值
* 字段对应的主键值
* 页码

### 2.3 聚簇索引

InnoDB的B+树索引也可以大致分为这两类：聚簇索引和二级索引。

（只有主键会建立一颗聚簇索引B+树，不管是唯一索引还是联合索引巴拉巴拉这些其他的索引都是二级索引）

上述图片描述的是聚簇索引，叶子节点中存储的是 主键->数据 。（学过的大概都知道）

### 2.4 二级索引

二级索引的叶子节点中存储的是 字段值 -> 主键。

如果查询二级索引，拿到主键后还需要去聚簇索引的B+树中通过主键拿到全部数据。这也被称为回表查询。

联合索引：

联合索引就是很多个字段一起共用同一颗B+树。

假如为 id、name、age建立联合索引 idx_id_name_age，那么它们三个字段就会使用同一颗B+树。

通过刚才的学习，我们知道B+树是按照一定顺序存储数据的，也就是有序的，聚簇索引按照主键排序，那么联合索引呢？

对于 idx_id_name_age 这个联合索引来说，顺序：按照id排序，id相同再按照name排序，name相同再按照age排序。

## 3. 回表

### 3.1 回表的代价

之前对于回表这个词都是一带而过，下面详细说一下。

假如对于 name、birthday、phone_num建立了一个联合索引：idx_name_birthday_phone_number。

对于以下SQL语句：

```sql
select * from person_info where name > 'xiaoming' and name < 'zengyi';
```

在使用联合索引 idx_name_birthday_phone_number时可以分为这两步：

* 从索引 idx_name_birthday_phone_number 中的B+树取出值在 xiaoming ~ zengyi 的数据。
* 由于索引只有 name birthday phone_number 这三个字段，而查询列表中想要的是 *，所以会拿着主键id去聚簇索引中拿全部记录。

由于索引 idx_name_birthday 对应的B+树的记录会首先按照name列的值进行排序，所以值在 xiaoming ~ zengyi 之间的记录在磁盘中的存储时是相连的，有可能就集中分布在同一页中，我们可以直接沿着链表将数据读取出来，这个过程称为顺序IO。但是根据name拿到的id并不相连，虽然聚簇索引中的id是顺序的，但是我们根据 name 拿到的id不相连，所以只能去不同的页去拿数据，这种读取方式被称为随机IO。一般情况下，顺序IO比随机IO快得多，所以这个SQL语句的两步其实是这样的：

* 会用到两个索引：联合(二级)索引和聚簇索引
* 访问二级索引时使用顺序IO，访问聚簇索引时使用随机IO。

需要回表的记录越多，使用二级索引的性能就越低。甚至某些查询宁愿用全表扫描也不用二级索引。

例如刚才那个SQL查出的记录占到表中总记录的９０％时，真的不如直接全表扫描。

那么什么时候使用索引，什么时候全表扫描呢？这是查询优化器需要做的事。

查询优化器会根据一条ＳＱＬ走了哪些索引占用了多少性能来计算分数，最后使用分数最低的那个SQL或者直接全表扫描。

### 3.2 覆盖索引

为了减少回表带来的性能损耗，MySQL更建议：查询列表尽量只包含索引列。

```sql
select　name, birthday, phone_number  
from person_info 
where name > 'xiaoming' and name < 'zengyi';
```

只要不让它回表，就不会有回表的坏处啦~

## 4. B+树索引的使用

前面两节详细描述了B+树的结构，温故：

* 每一个索引都对应一个B+树，B+树的节点是页。非叶子节点存储的是目录，叶子节点存储的是数据（聚簇索引和二级索引不同）
* B+树的叶子节点（页）按照双向链表连接，页的内部，即数据，按照单链表顺序连接。

![image](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230604182624-gdbyug3.png)

### 4.1 索引的代价

在介绍更好的使用索引前肯定要知道 为什么要更好的使用索引？因为索引也有缺点啊~

* 空间上的代价 ：这个是显而易见的，每建立一个索引，空间中就多一颗B+树，B+树的每一个节点都是一页，一页16K，当然很占空间喽。
* 时间上的代价 ：索引优化了查询操作，毕竟使用了二分查找。但是在增删改操作时，不仅需要修改数据页，还需要修改索引页。（不仅要修改叶子节点，又要修改非叶子节点）。时不时还会伴随着页分裂、页回收、记录移动的操作，这些都是对时间的消耗。

所以，一张表上索引建立的越多，就会占用越多的存储空间，在对数据增删改时的性能就会更差。

### 4.2 索引失效的场景

这个知识点想必大家面试题都背烂了，那么你知道

* 为什么不符合最左前缀匹配原则，索引就会失效吗？
* 为什么使用 '%xxx'，索引就会失效吗

下面来看一下为什么。

我们建立一张表，以便后续用到：

```sql
CREATE TABLE person_info(     
    id INT NOT NULL auto_increment,     
    name VARCHAR(100) NOT NULL,     
    birthday DATE NOT NULL,     
    phone_number CHAR(11) NOT NULL,     
    country varchar(100) NOT NULL,     
    PRIMARY KEY (id),     
    KEY idx_name_birthday_phone_number (name, birthday, phone_number) 
);
```

这张表中共有5个字段，其中id字段自动生成一颗聚簇索引的B+树，name、birthday、number这三个字段共用一颗B+树。

等等，在继续向下看之前，你需要回顾一下：

对于联合索引 idx_name_birthday_phone_number，排序的规则为：先按照 name 排序，name 相同再按照 birthday 排序，birthday相同再按照number 排序。

#### 4.2.1 最左前缀匹配

最左前缀匹配相比大家都知道，对于一个联合索引，如果有一个字段没有走索引，那么它后面的所有字段都不会走索引。

出现这种情况的原因就是联合索引的排序规则，刚才说过，排序规则是按照左边的列排序，左边的列相同再按照右边的列排序。

现在来看一下这几种情况：

1. select * from person_info where name = 'xiaoming' and birthday = '2000-01-01';

    这个会走索引吗？会，MySQL会在联合索引的B+树中找到 xiaoming 所在的页，再找它所在的组，最后确定第一个name为xiaoming的地方，再根据已经排好序的 birthday 进行顺序查找，直至找到目标。（拿到该目标的主键后去聚簇索引中回表查询）

2. select * from person_info where birthday = '2000-01-01';

    这个会走索引吗？不会，因为birthday所在的索引首先按照name进行排序，再按照birthday排序。都不按birthday排序了，怎么走索引？

3. select * from person_info where name < 'xiaoming' and name > 'xiaohong' and birthday = '2002-01-01';

    这个会走几个索引？一个name的索引，为什么呢？我们根据name走了索引之后获得了一个范围值，那么这个范围之可能如下所示：

    xiaohong 1998-03-12 

    xiaohong 2002-01-01 

    xiaohong 2005-08-09 

    xiaoming 2001-10-02 

    xiaoming 2002-09-13

    可以看到，虽然按照name排好序了，但是birthday并没有顺序可言，也就无法走索引，只能先拿到主键id，去聚簇索引中拿到对应数据后再判断一下这些数据的birthday是否为 2002-01-01。

    不仅仅是等值匹配、范围匹配会使用最左前缀匹配，分组操作也会使用最左前缀匹配原则，所以分组时也要注意哦。

#### 4.2.2 模糊查询

在进行模糊查询时，'xx%'和'x%x' 都不会失效，而'%xxx'就会导致索引失效。

为啥？前两个最起码第一个为x，MySQL可以在索引中找到第一个字符为x的数据，这样即使不能最终确定有哪些数据也能筛选掉不少的数据了。

但是给我个 '%xx' 是什么意思？第一个 '%' 你想让我怎么匹配怎么排序？肯定走不了索引啊~

4.2.3 排序

排序会出现什么问题呢？

MySQL规定：对于使用联合索引的场景，要求各个排序列的排序顺序是一致的，也就是要各个列要么全部降序，要么全部升序。

为什么呢？

假如有一下SQL语句：

```sql
select * from person_info  order by name asc, birthday desc limit 10;
```

这句sql的作用：

* 先从索引的最左边确定 name 列最小的值，然后从name列的最右边那条记录从右向左找10条(因为要求是birthday降序)
* 如果此name列不足10条，那么就要去下一个name列中重复上述操作。

这样非常麻烦，而且不能高效利用索引，所以MySQL就规定 使用联合索引的各个排序顺序都必须是一致的。

#### 4.2.4 运算与函数

要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是修饰过的形式。

因为where 条件字段类型与实际表中字段类型不匹配时，MySQL会进行隐式的类型转换，而类型转换会用到内置函数，导致在查询时没有走索引。

#### 4.2.5 or

我们有时候会用到or，select * from user where age = 18 or age = 20;

or左右的字段必须都加索引才会生效。

## 5. 如何挑选索引

### 5.1 常用于搜索、排序、分组的列

为常用于搜索、排序、分组的列创建索引，也就是说，只为出现在 where 子句中的列创建索引，出现在查询列表中的就没必要了（因为回表后自然能查出来）。

下面这一句，我们为name创建索引，而不为birthday和country创建索引。

select birthday, country from person_info where name='xxx';

### 5.2 考虑列的基数

什么是基数？一张表有10000条数据，它的每一列的基数一样吗？

不是，如果是id字段，10000条数据可能id都不一样。如果是age呢？如果是分数呢？

所以基数是指不相同的个数，我们应该尽量挑选基数大的列建立索引。

（像那些性别、状态就不要创建索引，但是如果经常用于分组的话也可以考虑）。

### 5.3 主键插入顺序

主键插入顺序尽量递增，并且尽量不要让主键变更。所以主键尽量设置为无意义且自增的。防止页分裂、记录重排序....造成的性能损耗。

‍
