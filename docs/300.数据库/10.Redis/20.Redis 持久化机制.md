---
title: Redis 持久化机制
date: 2023-06-11 12:25:09
permalink: /pages/4e0b96/
---
# Redis 持久化机制

## 1. 概述

`Redis` ​为了保证性能，会将所有数据放在内存中，那么万一 Redis 宕机，数据岂不是全部丢失了？

不要怕，Redis 自然想到了这一点，它提供了三种持久化机制将内存中的数据持久化到磁盘中。

1. **RDB**

   快照方式持久化（snapshot），快照在 Linux 就已经学过，保存所有数据的状态，下次开机直接按照这个状态恢复。

   因为保存的快照是以.rdb 结尾的文件，故称此方式为 RDB 持久化方式。
2. **AOF**

   （append only file）只追加日志文件，记录 Redis 所有写命令，下次开机将这些命令全部执行，即可恢复数据。
3. **混合型持久化**

   RDB 虽然快，但是数据丢失问题较为严重；AOF 虽然能保证数据安全，但是执行所有命令需要很长时间。

   所以 Redis4.x 以后，将两种方式结合，RDB 文件的内容放在 AOF 文件中，以.aof 文件的形式存储。在恢复数据时，先加载 rdb 的内容，再执行 aof 的内容。缺点是两种格式混合在一起难以阅读。

==需要注意的是，不论是哪种方式，都无法保证数据的绝对安全。==

## 2. RDB

snapshot 想必大家已经不陌生了，Linux 已经接触过这个机制：==保存现在的状态，随时准备恢复。==

拍摄的快照以**.rdb** 的形式保存在磁盘中。

假如在 Redis 宕机之前拍摄的快照为：

![image](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230102101206-yrbh2d0.png)

那么下次开机就可以即将这两个数据恢复。

Redis 提供了两种拍摄快照的方式 ：自动、手动。其中手动拍摄快照有两个命令：save、bgsave

![image](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230102101717-g9cnz1r.png)

### 2.1 手动快照

1. **save**

   由主进程完成快照的拍摄，持久化过程中其他命令阻塞。

   ![image](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230102105300-zs34lcz.png)
2. **bgsave**

   background save，主线程 fork 出一个子进程，由这个子进程完成持久化。

   ![image](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230102105321-usbmqdu.png)

> fork ：
>
> 当一个进程创建子进程时，底层的操作系统会创建该进程的副本，在类 unix 系统中创建子进程的操作会进行优化：在刚开始的时候，父子进程共享相同内存，直到父进程/子进程对内存进行写操作后结束共享，各用各的。

### 2.2 自动快照

在 redis.conf 配置文件中存在，参数如下:（版本不同，默认参数不同）

```vim
#   * After 3600 seconds (an hour) if at least 1 key changed
#   * After 300 seconds (5 minutes) if at least 100 keys changed
#   * After 60 seconds if at least 10000 keys changed

# save 3600 1
# save 300 100
# save 60 10000
```

解释 ：

1h 内有一个键被改变会触发快照拍摄。

5mins 内有 100 个键被改变会触发快照拍摄。

1min 内有 10000 个键被改变会触发快照拍摄。

这些快照的拍摄方式都是 bgsave。

**优点 ：**

* rdb 文件的加载速度特别快，远超 aof。

* 使用单独子进程来进行持久化，主进程不会进行任何 IO 操作。

**缺点 ：**

* 容易造成数据丢失。

* 每次拍快照都要创建子进程，浪费资源.。

## 3. AOF

这种机制可以将所有客户端执行的写命令记录到日志文件中，`AOF` ​持久化会将被执行的写命令写到 AOF 文件末尾，以此来记录数据发生变化的全过程，因此只要 Redis 从头到尾执行一遍 AOF 文件中的命令，就可以恢复之前的数据。

### 3.1 AOF 机制

`RDB` ​是间隔一段时间进行持久化，如果持久化之间的时间内发生故障，会出现数据丢失。而 `AOF` ​持久化方式能很好的解决 `RDB` ​持久化方式造成的数据丢失，`AOF` ​持久化到硬盘中的并不是内存中的数据快照，而是**将所有写命令记录到日志中**。

AOF 能做到最多丢失 1s 内的数据，甚至不丢失数据。

Redis 提供了三种 AOF 策略 ：

* `appendfsync always`

  每执行一次写命令，都对 aof 文件续写。
* `appendfsync everysec`​

  每一秒进行一次 aof 文件续写，这一秒的写命令都会记录。
* `appendfsync no`

  并不是不开启，而是将 aof 续写的时机交给操作系统管理，操作系统开心了就续写，不开心就不续写。

这三种策略其实也就是控制aof缓存写入日志的时机罢了，什么？aof缓存是什么呢？往下看

AOF文件记录的具体过程 ：先将命令写入内存，再将命令写入日志。
1. 命令追加 ：将新执行的命令追加到 aof缓存 中
2. 文件写入 ：将 aof缓存 中的数据写到aof文件中
这一步需要进行系统调用，看过操作系统的都知道，系统调用需要触发函数，比如read、write，redis用的是 <font color=Blue>fsync()</font>, 这个命令怎么触发？
就是上面配置的AOF策略，always、everysec、no。

所以说，AOF的三种策略其实就是控制执行 fsync命令 的时机。

**优点 ：**

* 保证数据丢失风险降到最低

**缺点 ：**

* aof 文件的体积会很大，同时加载速度很慢

### 3.2 AOF 文件的重写

随着 `Redis` ​在线上运行的时间越来越久，客户端执行的命令越来越多，`AOF` ​的文件也会越来越大。

当我们执行 100 次 `set name 张三`​，其中 99 次都是多余的，因为想要恢复只要执行一次 `set name 张三` ​就行了。为了压缩 AOF 文件的体积，Redis 提供了 `AOF文件重写机制`​。

有两种方式触发 AOF 的重写机制：

* 手动：执行 `bgrewrite`​，background rewrite，不会阻塞 Redis

* 自动：在配置文件中进行配置

  ```vim
  auto-aof-rewrite-percentage 100
  auto-aof-rewrite-min-size 64mb
  ```
  
  当 AOF 文件体积大于 64MB，或者比上一次重写之后体积大了 100%，会自动触发。

  如果重写过于频繁，可以考虑将 auto-aof-rewrite-percentage 设置为更大。

‍

> AOF 重写机制并没有根据现有的AOF文件重写，而是是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。

为什么不使用原有的 AOF 文件呢?

如果在原有的AOF文件基础上重新，但凡AOF文件重写过程中宕机或者失败，原有的AOF文件就被污染了，可能无法用于数据恢复。所以保留原有的AOF文件是保底策略。

::: note 重写的具体过程
重写使用到了写时复制

写时复制 ：父进程 fork 出一个子进程，两个进程共用同一块内存区域（二者的虚拟内存虽然不相同，但是虚拟内存对应的物理内存是一样的），主进程是可以正常处理读请求的，但是如果出现写请求，且操作的数据是已经存在的，⭐操作系统就会将**这个数据在父进程的物理内存**复制一份交给子进程。注意，这里复制的物理内存是 修改了哪个数据就只复制这个数据的物理内存，而不是将父进程的所有物理内存都复制一份。


Redis 设置了一个 **AOF 重写缓冲区**。 在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」。

当子进程完成AOF的重写后，会通知父进程，父进程操作**AOF 重写缓冲区**，将追加的数据写入AOF文件（这个步骤是父进程进行的）
:::

需要注意的是 ：RDB快照和AOF重写的过程都用到了写时复制。

## 4. 混合型持久化

因为 `RDB` ​虽然加载快但是存在数据丢失，`AOF` ​数据安全但是加载缓慢，`Redis` ​为了解决这个问题，带来了一个新的持久化选项——混合持久化。将 `RDB` ​文件的内容和增量的 `AOF` ​日志文件存在一起。这里的 `AOF` ​日志不再是全量 的日志，而是自持久化开始到持久化结束的这段时间发生的增量 `AOF` ​日志，通常这部分 `AOF` ​日志很小。`Redis` ​重启的时候，可以先加载 `RDB` ​的内容，然后再重放增量 `AOF` ​日志，就可以完全替代之前的 `AOF` ​全量文件重放，恢复效率因此大幅得到提升（混合型持久化最终生成的文件后缀是 `.aof`​，可以通过 `redis.conf` ​文件中 `aof-use-rdb-preamble yes` ​配置开启）。

* **优点：**

  结合了 `RDB` ​和 `AOF` ​的优点，使得数据恢复的效率大幅提升

* **缺点：**

  兼容性不好，`Redis-4.x` ​新增，虽然最终的文件也是 `.aof` ​格式的文件，但在 `4.0` ​之前版本都不识别该 `aof` ​文件，同时由于前部分是 `RDB` ​格式，阅读性较差。

## 5. 总结

![image](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230102132247-ww8ti4d.png)
