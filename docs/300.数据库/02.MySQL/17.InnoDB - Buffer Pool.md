---
title: InnoDB - Buffer Pool
date: 2023-06-17 20:35:21
permalink: /pages/31e077/
---

## 1. 什么是Buffer Pool

通过前几篇文章的学习我们大致了解到：<font color=Red>**对于InnoDB引擎来说，所有的数据都是存在磁盘中，用的时候以页为单位加载到内存中的。**</font>
这样就减小了select一条数据还要来回进行磁盘IO的性能损耗。但是加载到内存中后并不是用完就丢了，而是放在缓存中，下次用直接拿就好了。

为了缓存这些页数据，MySQL服务器启动的时候就申请了一片连续的内存，叫做Buffer Pool。它的大小通常是128M，这个值可以设置，如果小于5M会自动设置为5M。

## 2. Buffer Pool的组成

Buffer Pool需要缓存从磁盘加载出来的页，磁盘中的页是16k，BufferPool里面页的和磁盘中的页一样大。为了表示区分，接下来将称Buffer Pool中的页为缓存页。

一般来说，为了更好的管理数据，都会给数据添加一些“元数据”、“头信息”之类的<font color=Red>**描述数据的数据**</font>， 例如对象Object的对象头、MySQL的隐藏字段、消息队列中消息的元数据....
在这里也不意外，InnoDB引擎也对Buffer Pool缓存的页增加了描述信息：<font color=Red>控制块</font>。每一个缓存页都有它对应的控制块，
每一个控制块中的信息包括 该页的页号、该页所属的表号、该页在Buffer Pool中的位置、链表节点信息.... 
所有控制块的内存大小是相同的（大概是页的8%），控制块和缓存页是一一对应的，他们都存放在Buffer Pool中，
其中控制块被放在缓存页前面，所以在Buffer Pool中，控制块和缓存页对应的空间看起来就跟这样式的：

![image](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230617142943-ahq7xkt.png)

## 3. free链表

最初启动MySQL时，需要完成Buffer Pool的初始化过程，就是向操作系统申请Buffer Pool的空间，然后将它划分为若干对控制块和缓存页，
但是此时并没有页被缓存到Buffer中（因为还没有select语句），后面随着程序的运行才会不断的有页被放入Buffer中。
但是问题来了：<font color=Red>页应该放在Buffer Pool的哪一个位置呢？</font>或者说，怎么知道哪些缓存页是没有用过的？
难道要挨个遍历缓存页查看它是否为空吗？

这个是很好解决的，我们<font color=Red>把所有空闲的缓存页对应的控制块组成一个链表，我们称之为**free链表**。</font>

当从磁盘加载出一个页并且确定需要缓存它时，在free链表中拿一个控制块，将该页的基本信息记录在控制块中并把控制块从free链表中删除。

那么刚才的图改一下就成了这个样子：

![](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230617144652-hjgd4wm.png)

当我们使用select语句时就会从磁盘中读取页出来，当读取出一页时，会将free链表的第一个控制块填上这个页的信息，然后将它从free链表删除：

![](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230617144747-kih8oqe.png)

## 4. flush链表

缓存虽好，但问题也挺多，例如：<font color=Red>**脏数据**</font>。什么是脏数据？就是你把数据从磁盘中读到内存操作，内存中的数据被修改了但是并没有写入磁盘，造成了同一个数据在内存中和磁盘中不一样。这就是脏数据。

上面说过，MySQL在Buffer中维护了很多个控制块-缓存页，操作一段时间后肯定会出现脏数据，也肯定要往磁盘中同步数据，那么我们怎么知道哪些页是脏数据呢？一个一个遍历？MySQL的设计者肯定不会这么傻。

他们增加了一个链表：<font color=Red>**flush链表，用来记录脏数据页**</font>。所有被写过的页对应的控制块都会被加入这个链表中，等数据同步的时候直接遍历flush链表，通过控制块找到缓存页，将缓存页刷到磁盘中。

那么刚才的图继续完善：

（缓存块1和缓存块6都没有被使用，缓存块13和缓存块45都产生了脏数据）

![](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230617144927-23blirr.png)

free链表和flush都有一个头节点不存储任何控制块。

![](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230617145204-e3gxecm.png)
## 5. LRU链表

你看到LRU这个词可能会懵逼，但是你大概率学过LRU：Redis的淘汰策略之一，LRU策略。

LRU ：Least Recently Used，最近最少使用。LRU是典型的内存管理算法，它的思想用通俗的话来说就是最近被频繁访问的数据会具备更高的留存，淘汰那些不常被访问的数据。

每当使用到一个数据时，将它放在最前面，删除最后面的数据。设想一个队列，规定它只能从队头进入队尾删除，差不多就是LRU的思想了。

为什么MySQL要使用LRU算法呢？Buffer Pool大小毕竟是有限的，我们要把那些旧的数据从Buffer Pool中移除。

> 那么问题来了，为什么一定要移除旧的呢？不是应该移除最少使用过的吗？
>
> 其实可以看一下时间局部性和空间局部性。

先来看一下简单的LRU链表的实现吧：

* 如果该页不在Buffer Pool中，当把该页从磁盘中加载到Buffer Pool的缓存页中时，就把该缓存页对应的控制块放到LRU链表头部。
* 如果该页已经在Buffer Pool中，就把该页对应的缓存块移动到LRU链表头部。

也就是说，<font color=Red>只要用到某个缓存页，就把这个缓存页对应的控制块移动到LRU链表头部，那么尾部就是最近最少使用到的缓存页了。</font>

<font color=Red>**但是MySQL并没有直接使用上述LRU链表。**</font>

因为有两个情况对于这种简单的LRU链表来说特别尴尬：

1. InnoDB的预读。

   预读 ：InnoDB认为执行当前的请求可能之后会读取某些页，就提前把这些页加载到Buffer Pool中。根据触发的方式不同，预读又可以分为两类：

    * 线性预读：

      如果顺序访问了某个区(extent)的页面数量超过了特定值，就会触发一次异步读取下一个区中全部的页到Buffer Pool中。<font color=Red>**异步就意味着从磁盘加载这些被预读的页面并不会影响当前工作线程的正常执行。**</font>

    * 随机预读：

      如果Buffer Pool中已经缓存了某个区的13个连续的页面，不论这些页是顺序读取还是随机读取，都会触发一次随机预读，异步读取本区中所有其他的页加载到缓存。

   预读本来是好事，如果预读的页被访问到，就可以大大提升效率。可是如果用不到呢？这些预读的页会被放到Buffer Pool的LRU链表的头部，将原来的页挤掉很多，万一预读的页不经常用到，就会出现<font color=Red>**劣币驱逐良币**</font>的现象，大大减小命中率。

2. 扫描全表

   有时候我们的SQL语句需要对全表进行扫描，这意味着要将这个表对应的所有页都加载到Buffer Pool中，同样也要放入LRU链表的头部，同样会出现劣币驱逐良币的现象。

总结一下这两种特殊情况吧：有时候会一次扫描到很多使用不到页，会出现劣币驱除良币的现象。

因为有这两种特殊情况的存在，MySQL将LRU链表分为两个部分：

* young区域 ：存储使用频率很高的缓存页
* old区域 ：存储使用频率不高的缓存页

（有没有很像JVM的新生代和老年代？）

如图所示，缓存页2、45、1处在young区域，为经常使用到的缓存页。

缓存页13、6处在old区域，为使用频率不高的缓存页。

![](https://typorehwf.oss-cn-chengdu.aliyuncs.com/image-20230617152655-s65326o.png)

需要注意的是，MySQL按照比例给young区域和old区域分配大小，一般来说是 63 ：37，随着程序的运行，一个控制块可能从young区域跳到old区域，也可能从old区域跳到young区域。

有了这个划分为young和old区域的LRU链表后，MySQL就可以解决我们刚才的问题了：

1. 针对预读：

   预读的主要危害：预读出来的缓存页可能后续就不访问。

   优化：当磁盘上的某个页面在首次加载到Buffer Pool中时，优先将缓存页对应的控制块加入到old区域的头部，这样针对预读到Buffer Pool却不进行后续访问的缓存页就会逐渐从old区域逐出，而不会影响young区域中比较经常使用道到的缓存页

2. 针对全表扫描：

   全表扫描的危害：在进行全表扫描时，虽然首次被加载到Buffer Pool的页被放在了old区域的头部，但是后续会被马上访问到，每次进行访问的时候又会将其放到young区域的头部，这样仍会影响原本就经常访问到的缓存页。

   优化：全表扫描的执行频率非常低，（毕竟谁也不会没事就在那写select * from user），所以MySQL规定，<font color=Green>在对某个处在old区域的缓存页第一访问时就在它对应的控制块中记录下来这个访问时间，如果后续的访问时间与第一次的访问时间隔的时间很短，大概率就是全表扫描，就不把它移动到young区域的头部。否则就把它移动到young区域。</font>

当然，MySQL的LRU比上述描述的还要复杂得多，不过在复杂了我也不会了~~~~

## 6. 总结

1. 内存与磁盘之间进行交互，有必要设置一个缓存。
2. Buffer Pool本质上是内存中的一块连续空间
3. Buffer Pool的组成 ：控制块、缓存页。
4. InnoDB引擎使用了很多链表来管理Buffer Pool：

    * free链表 ：记录所有未使用的缓存页
    * flush链表 ：记录所有脏缓存页
    * LRU链表 ：用于淘汰缓存页，分为old和young两个区域。
